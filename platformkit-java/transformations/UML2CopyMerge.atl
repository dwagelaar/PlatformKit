-- @atlcompiler atl2006
-- @nsURI UML2=http://www.eclipse.org/uml2/3.0.0/UML
-- $Id$
-- Copies UML2 models
module UML2CopyMerge;

create OUT : UML2		-- The copied model
from IN : UML2, 		-- The first input model
     MERGE : UML2; 		-- The second input model

helper def : inElements : Set(UML2!"ecore::EObject") = 
	UML2!"ecore::EObject".allInstancesFrom('IN');

helper context OclAny def : isInElement : Boolean =
	thisModule.inElements->includes(self);

-- ======================================================================
-- Ecore copying rules begin
-- ======================================================================
-- Generated by: EModelCopyGenerator.atl 7948 2010-01-31 11:48:43Z dwagelaa

rule EAnnotation {
    from s : UML2!"ecore::EAnnotation" (s.isInElement)
    to t : UML2!"ecore::EAnnotation" (
        source <- s.source,
        eAnnotations <- s.eAnnotations,
        details <- s.details,
        contents <- s.contents,
        references <- s.references)
}

rule EStringToStringMapEntry {
    from s : UML2!"ecore::EStringToStringMapEntry" (s.isInElement)
    to t : UML2!"ecore::EStringToStringMapEntry" (
        key <- s.key,
        value <- s.value)
}

-- ======================================================================
-- Ecore copying rules end
-- ======================================================================

-- ======================================================================
-- UML2 copying rules begin
-- ======================================================================
-- Generated by: EModelCopyGenerator.atl 7948 2010-01-31 11:48:43Z dwagelaa
-- Generated for: http://www.eclipse.org/uml2/3.0.0/UML

rule Comment {
    from s : UML2!"uml::Comment" (s.isInElement)
    to t : UML2!"uml::Comment" (
        body <- s.body,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        annotatedElement <- s.annotatedElement)
}

rule Package {
    from s : UML2!"uml::Package" (
		if s.oclIsTypeOf(UML2!"uml::Package") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Package" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        packageMerge <- s.packageMerge,
        packagedElement <- s.packagedElement,
        profileApplication <- s.profileApplication)
}

rule Dependency {
    from s : UML2!"uml::Dependency" (
		if s.oclIsTypeOf(UML2!"uml::Dependency") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Dependency" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client)
}

rule ElementImport {
    from s : UML2!"uml::ElementImport" (s.isInElement)
    to t : UML2!"uml::ElementImport" (
        visibility <- s.visibility,
        alias <- s.alias,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        importedElement <- s.importedElement)
}

rule PackageImport {
    from s : UML2!"uml::PackageImport" (s.isInElement)
    to t : UML2!"uml::PackageImport" (
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        importedPackage <- s.importedPackage)
}

rule Constraint {
    from s : UML2!"uml::Constraint" (
		if s.oclIsTypeOf(UML2!"uml::Constraint") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Constraint" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule Association {
    from s : UML2!"uml::Association" (
		if s.oclIsTypeOf(UML2!"uml::Association") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Association" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

rule TemplateBinding {
    from s : UML2!"uml::TemplateBinding" (s.isInElement)
    to t : UML2!"uml::TemplateBinding" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        signature <- s.signature,
        parameterSubstitution <- s.parameterSubstitution)
}

rule TemplateSignature {
    from s : UML2!"uml::TemplateSignature" (
		if s.oclIsTypeOf(UML2!"uml::TemplateSignature") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::TemplateSignature" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameter <- s.parameter,
        ownedParameter <- s.ownedParameter)
}

rule TemplateParameter {
    from s : UML2!"uml::TemplateParameter" (
		if s.oclIsTypeOf(UML2!"uml::TemplateParameter") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::TemplateParameter" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault)
}

rule TemplateParameterSubstitution {
    from s : UML2!"uml::TemplateParameterSubstitution" (s.isInElement)
    to t : UML2!"uml::TemplateParameterSubstitution" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        formal <- s.formal,
        actual <- s.actual,
        ownedActual <- s.ownedActual)
}

rule Generalization {
    from s : UML2!"uml::Generalization" (s.isInElement)
    to t : UML2!"uml::Generalization" (
        isSubstitutable <- s.isSubstitutable,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        general <- s.general,
        generalizationSet <- s.generalizationSet)
}

rule GeneralizationSet {
    from s : UML2!"uml::GeneralizationSet" (s.isInElement)
    to t : UML2!"uml::GeneralizationSet" (
        name <- s.name,
        visibility <- s.visibility,
        isCovering <- s.isCovering,
        isDisjoint <- s.isDisjoint,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        powertype <- s.powertype,
        generalization <- s.generalization)
}

rule Substitution {
    from s : UML2!"uml::Substitution" (s.isInElement)
    to t : UML2!"uml::Substitution" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        contract <- s.contract)
}

rule Realization {
    from s : UML2!"uml::Realization" (
		if s.oclIsTypeOf(UML2!"uml::Realization") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Realization" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping)
}

rule Abstraction {
    from s : UML2!"uml::Abstraction" (
		if s.oclIsTypeOf(UML2!"uml::Abstraction") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Abstraction" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping)
}

rule OpaqueExpression {
    from s : UML2!"uml::OpaqueExpression" (s.isInElement)
    to t : UML2!"uml::OpaqueExpression" (
        name <- s.name,
        visibility <- s.visibility,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        behavior <- s.behavior)
}

rule Parameter {
    from s : UML2!"uml::Parameter" (s.isInElement)
    to t : UML2!"uml::Parameter" (
        name <- s.name,
        visibility <- s.visibility,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        direction <- s.direction,
        isException <- s.isException,
        isStream <- s.isStream,
        effect <- s.effect,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        templateParameter <- s.templateParameter,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        parameterSet <- s.parameterSet,
        defaultValue <- s.defaultValue)
}

rule ConnectorEnd {
    from s : UML2!"uml::ConnectorEnd" (s.isInElement)
    to t : UML2!"uml::ConnectorEnd" (
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        role <- s.role,
        partWithPort <- s.partWithPort)
}

rule Property {
    from s : UML2!"uml::Property" (
		if s.oclIsTypeOf(UML2!"uml::Property") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Property" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        isDerived <- s.isDerived,
        isDerivedUnion <- s.isDerivedUnion,
        aggregation <- s.aggregation,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        templateParameter <- s.templateParameter,
        deployment <- s.deployment,
        redefinedProperty <- s.redefinedProperty,
        defaultValue <- s.defaultValue,
        subsettedProperty <- s.subsettedProperty,
        association <- s.association,
        qualifier <- s.qualifier)
}

rule Deployment {
    from s : UML2!"uml::Deployment" (s.isInElement)
    to t : UML2!"uml::Deployment" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        deployedArtifact <- s.deployedArtifact,
        configuration <- s.configuration)
}

rule DeploymentSpecification {
    from s : UML2!"uml::DeploymentSpecification" (s.isInElement)
    to t : UML2!"uml::DeploymentSpecification" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        fileName <- s.fileName,
        deploymentLocation <- s.deploymentLocation,
        executionLocation <- s.executionLocation,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        nestedArtifact <- s.nestedArtifact,
        manifestation <- s.manifestation,
        ownedOperation <- s.ownedOperation,
        ownedAttribute <- s.ownedAttribute)
}

rule Artifact {
    from s : UML2!"uml::Artifact" (
		if s.oclIsTypeOf(UML2!"uml::Artifact") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Artifact" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        fileName <- s.fileName,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        nestedArtifact <- s.nestedArtifact,
        manifestation <- s.manifestation,
        ownedOperation <- s.ownedOperation,
        ownedAttribute <- s.ownedAttribute)
}

rule Manifestation {
    from s : UML2!"uml::Manifestation" (s.isInElement)
    to t : UML2!"uml::Manifestation" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        utilizedElement <- s.utilizedElement)
}

rule Operation {
    from s : UML2!"uml::Operation" (s.isInElement)
    to t : UML2!"uml::Operation" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isAbstract <- s.isAbstract,
        concurrency <- s.concurrency,
        isQuery <- s.isQuery,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        ownedParameter <- s.ownedParameter,
        method <- s.method,
        raisedException <- s.raisedException,
        ownedParameterSet <- s.ownedParameterSet,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        redefinedOperation <- s.redefinedOperation,
        bodyCondition <- s.bodyCondition)
}

rule Class {
    from s : UML2!"uml::Class" (
		if s.oclIsTypeOf(UML2!"uml::Class") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Class" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception)
}

rule InterfaceRealization {
    from s : UML2!"uml::InterfaceRealization" (s.isInElement)
    to t : UML2!"uml::InterfaceRealization" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        contract <- s.contract)
}

rule Interface {
    from s : UML2!"uml::Interface" (s.isInElement)
    to t : UML2!"uml::Interface" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation,
        nestedClassifier <- s.nestedClassifier,
        redefinedInterface <- s.redefinedInterface,
        ownedReception <- s.ownedReception,
        protocol <- s.protocol)
}

rule Reception {
    from s : UML2!"uml::Reception" (s.isInElement)
    to t : UML2!"uml::Reception" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isAbstract <- s.isAbstract,
        concurrency <- s.concurrency,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        ownedParameter <- s.ownedParameter,
        method <- s.method,
        raisedException <- s.raisedException,
        ownedParameterSet <- s.ownedParameterSet,
        signal <- s.signal)
}

rule Signal {
    from s : UML2!"uml::Signal" (s.isInElement)
    to t : UML2!"uml::Signal" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute)
}

rule ProtocolStateMachine {
    from s : UML2!"uml::ProtocolStateMachine" (s.isInElement)
    to t : UML2!"uml::ProtocolStateMachine" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        region <- s.region,
        submachineState <- s.submachineState,
        connectionPoint <- s.connectionPoint,
        extendedStateMachine <- s.extendedStateMachine,
        conformance <- s.conformance)
}

rule StateMachine {
    from s : UML2!"uml::StateMachine" (
		if s.oclIsTypeOf(UML2!"uml::StateMachine") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::StateMachine" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        region <- s.region,
        submachineState <- s.submachineState,
        connectionPoint <- s.connectionPoint,
        extendedStateMachine <- s.extendedStateMachine)
}

rule Region {
    from s : UML2!"uml::Region" (s.isInElement)
    to t : UML2!"uml::Region" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        subvertex <- s.subvertex,
        transition <- s.transition,
        extendedRegion <- s.extendedRegion)
}

rule Transition {
    from s : UML2!"uml::Transition" (
		if s.oclIsTypeOf(UML2!"uml::Transition") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Transition" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        source <- s.source,
        target <- s.target,
        redefinedTransition <- s.redefinedTransition,
        guard <- s.guard,
        effect <- s.effect,
        trigger <- s.trigger)
}

rule Trigger {
    from s : UML2!"uml::Trigger" (s.isInElement)
    to t : UML2!"uml::Trigger" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        event <- s.event,
        port <- s.port)
}

rule Port {
    from s : UML2!"uml::Port" (s.isInElement)
    to t : UML2!"uml::Port" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        isDerived <- s.isDerived,
        isDerivedUnion <- s.isDerivedUnion,
        aggregation <- s.aggregation,
        isBehavior <- s.isBehavior,
        isService <- s.isService,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        templateParameter <- s.templateParameter,
        deployment <- s.deployment,
        redefinedProperty <- s.redefinedProperty,
        defaultValue <- s.defaultValue,
        subsettedProperty <- s.subsettedProperty,
        association <- s.association,
        qualifier <- s.qualifier,
        redefinedPort <- s.redefinedPort,
        protocol <- s.protocol)
}

rule State {
    from s : UML2!"uml::State" (
		if s.oclIsTypeOf(UML2!"uml::State") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::State" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        submachine <- s.submachine,
        connection <- s.connection,
        connectionPoint <- s.connectionPoint,
        redefinedState <- s.redefinedState,
        stateInvariant <- s.stateInvariant,
        entry <- s.entry,
        exit <- s.exit,
        doActivity <- s.doActivity,
        deferrableTrigger <- s.deferrableTrigger,
        region <- s.region)
}

rule ConnectionPointReference {
    from s : UML2!"uml::ConnectionPointReference" (s.isInElement)
    to t : UML2!"uml::ConnectionPointReference" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        entry <- s.entry,
        exit <- s.exit)
}

rule Pseudostate {
    from s : UML2!"uml::Pseudostate" (s.isInElement)
    to t : UML2!"uml::Pseudostate" (
        name <- s.name,
        visibility <- s.visibility,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression)
}

rule ProtocolConformance {
    from s : UML2!"uml::ProtocolConformance" (s.isInElement)
    to t : UML2!"uml::ProtocolConformance" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        generalMachine <- s.generalMachine)
}

rule Connector {
    from s : UML2!"uml::Connector" (s.isInElement)
    to t : UML2!"uml::Connector" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        redefinedConnector <- s.redefinedConnector,
        end <- s.end,
        contract <- s.contract)
}

rule Extension {
    from s : UML2!"uml::Extension" (s.isInElement)
    to t : UML2!"uml::Extension" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

rule ExtensionEnd {
    from s : UML2!"uml::ExtensionEnd" (s.isInElement)
    to t : UML2!"uml::ExtensionEnd" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        isDerived <- s.isDerived,
        isDerivedUnion <- s.isDerivedUnion,
        aggregation <- s.aggregation,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        templateParameter <- s.templateParameter,
        deployment <- s.deployment,
        redefinedProperty <- s.redefinedProperty,
        defaultValue <- s.defaultValue,
        subsettedProperty <- s.subsettedProperty,
        association <- s.association,
        qualifier <- s.qualifier)
}

rule Image {
    from s : UML2!"uml::Image" (s.isInElement)
    to t : UML2!"uml::Image" (
        content <- s.content,
        location <- s.location,
        format <- s.format,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment)
}

rule Model {
    from s : UML2!"uml::Model" (s.isInElement)
    to t : UML2!"uml::Model" (
        name <- s.name,
        visibility <- s.visibility,
        viewpoint <- s.viewpoint,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        packageMerge <- s.packageMerge,
        packagedElement <- s.packagedElement,
        profileApplication <- s.profileApplication)
}

rule ParameterSet {
    from s : UML2!"uml::ParameterSet" (s.isInElement)
    to t : UML2!"uml::ParameterSet" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        parameter <- s.parameter,
        condition <- s.condition)
}

rule DataType {
    from s : UML2!"uml::DataType" (
		if s.oclIsTypeOf(UML2!"uml::DataType") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::DataType" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation)
}

rule OperationTemplateParameter {
    from s : UML2!"uml::OperationTemplateParameter" (s.isInElement)
    to t : UML2!"uml::OperationTemplateParameter" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault)
}

rule ConnectableElementTemplateParameter {
    from s : UML2!"uml::ConnectableElementTemplateParameter" (s.isInElement)
    to t : UML2!"uml::ConnectableElementTemplateParameter" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault)
}

rule CollaborationUse {
    from s : UML2!"uml::CollaborationUse" (s.isInElement)
    to t : UML2!"uml::CollaborationUse" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        roleBinding <- s.roleBinding)
}

rule Collaboration {
    from s : UML2!"uml::Collaboration" (s.isInElement)
    to t : UML2!"uml::Collaboration" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        collaborationRole <- s.collaborationRole)
}

rule UseCase {
    from s : UML2!"uml::UseCase" (s.isInElement)
    to t : UML2!"uml::UseCase" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        include <- s.include,
        extend <- s.extend,
        extensionPoint <- s.extensionPoint,
        subject <- s.subject)
}

rule Include {
    from s : UML2!"uml::Include" (s.isInElement)
    to t : UML2!"uml::Include" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        addition <- s.addition)
}

rule Extend {
    from s : UML2!"uml::Extend" (s.isInElement)
    to t : UML2!"uml::Extend" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        extendedCase <- s.extendedCase,
        condition <- s.condition,
        extensionLocation <- s.extensionLocation)
}

rule ExtensionPoint {
    from s : UML2!"uml::ExtensionPoint" (s.isInElement)
    to t : UML2!"uml::ExtensionPoint" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression)
}

rule RedefinableTemplateSignature {
    from s : UML2!"uml::RedefinableTemplateSignature" (s.isInElement)
    to t : UML2!"uml::RedefinableTemplateSignature" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        parameter <- s.parameter,
        ownedParameter <- s.ownedParameter,
        extendedSignature <- s.extendedSignature)
}

rule ClassifierTemplateParameter {
    from s : UML2!"uml::ClassifierTemplateParameter" (s.isInElement)
    to t : UML2!"uml::ClassifierTemplateParameter" (
        allowSubstitutable <- s.allowSubstitutable,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        parameteredElement <- s.parameteredElement,
        ownedParameteredElement <- s.ownedParameteredElement,
        default <- s.default,
        ownedDefault <- s.ownedDefault,
        constrainingClassifier <- s.constrainingClassifier)
}

rule StringExpression {
    from s : UML2!"uml::StringExpression" (s.isInElement)
    to t : UML2!"uml::StringExpression" (
        name <- s.name,
        visibility <- s.visibility,
        symbol <- s.symbol,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        operand <- s.operand,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        subExpression <- s.subExpression)
}

rule Expression {
    from s : UML2!"uml::Expression" (
		if s.oclIsTypeOf(UML2!"uml::Expression") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Expression" (
        name <- s.name,
        visibility <- s.visibility,
        symbol <- s.symbol,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        operand <- s.operand)
}

rule Usage {
    from s : UML2!"uml::Usage" (s.isInElement)
    to t : UML2!"uml::Usage" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client)
}

rule PackageMerge {
    from s : UML2!"uml::PackageMerge" (s.isInElement)
    to t : UML2!"uml::PackageMerge" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        mergedPackage <- s.mergedPackage)
}

rule ProfileApplication {
    from s : UML2!"uml::ProfileApplication" (s.isInElement)
    to t : UML2!"uml::ProfileApplication" (
        isStrict <- s.isStrict,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        appliedProfile <- s.appliedProfile)
}

rule Enumeration {
    from s : UML2!"uml::Enumeration" (s.isInElement)
    to t : UML2!"uml::Enumeration" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation,
        ownedLiteral <- s.ownedLiteral)
}

rule EnumerationLiteral {
    from s : UML2!"uml::EnumerationLiteral" (s.isInElement)
    to t : UML2!"uml::EnumerationLiteral" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        deployment <- s.deployment,
        templateParameter <- s.templateParameter,
        classifier <- s.classifier,
        slot <- s.slot,
        specification <- s.specification)
}

rule InstanceSpecification {
    from s : UML2!"uml::InstanceSpecification" (
		if s.oclIsTypeOf(UML2!"uml::InstanceSpecification") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::InstanceSpecification" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        deployment <- s.deployment,
        templateParameter <- s.templateParameter,
        classifier <- s.classifier,
        slot <- s.slot,
        specification <- s.specification)
}

rule Slot {
    from s : UML2!"uml::Slot" (s.isInElement)
    to t : UML2!"uml::Slot" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        definingFeature <- s.definingFeature,
        value <- s.value)
}

rule PrimitiveType {
    from s : UML2!"uml::PrimitiveType" (s.isInElement)
    to t : UML2!"uml::PrimitiveType" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation)
}

rule LiteralInteger {
    from s : UML2!"uml::LiteralInteger" (s.isInElement)
    to t : UML2!"uml::LiteralInteger" (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule LiteralString {
    from s : UML2!"uml::LiteralString" (s.isInElement)
    to t : UML2!"uml::LiteralString" (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule LiteralBoolean {
    from s : UML2!"uml::LiteralBoolean" (s.isInElement)
    to t : UML2!"uml::LiteralBoolean" (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule LiteralNull {
    from s : UML2!"uml::LiteralNull" (s.isInElement)
    to t : UML2!"uml::LiteralNull" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule InstanceValue {
    from s : UML2!"uml::InstanceValue" (s.isInElement)
    to t : UML2!"uml::InstanceValue" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        instance <- s.instance)
}

rule LiteralUnlimitedNatural {
    from s : UML2!"uml::LiteralUnlimitedNatural" (s.isInElement)
    to t : UML2!"uml::LiteralUnlimitedNatural" (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type)
}

rule OpaqueBehavior {
    from s : UML2!"uml::OpaqueBehavior" (
		if s.oclIsTypeOf(UML2!"uml::OpaqueBehavior") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::OpaqueBehavior" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

rule FunctionBehavior {
    from s : UML2!"uml::FunctionBehavior" (s.isInElement)
    to t : UML2!"uml::FunctionBehavior" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification)
}

rule OpaqueAction {
    from s : UML2!"uml::OpaqueAction" (s.isInElement)
    to t : UML2!"uml::OpaqueAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        body <- s.body,
        language <- s.language,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        inputValue <- s.inputValue,
        outputValue <- s.outputValue)
}

rule StructuredActivityNode {
    from s : UML2!"uml::StructuredActivityNode" (
		if s.oclIsTypeOf(UML2!"uml::StructuredActivityNode") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::StructuredActivityNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node)
}

rule Activity {
    from s : UML2!"uml::Activity" (s.isInElement)
    to t : UML2!"uml::Activity" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        isReadOnly <- s.isReadOnly,
        isSingleExecution <- s.isSingleExecution,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        variable <- s.variable,
        node <- s.node,
        edge <- s.edge,
        partition <- s.partition,
        group <- s.group)
}

rule Variable {
    from s : UML2!"uml::Variable" (s.isInElement)
    to t : UML2!"uml::Variable" (
        name <- s.name,
        visibility <- s.visibility,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        type <- s.type,
        templateParameter <- s.templateParameter,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule ActivityPartition {
    from s : UML2!"uml::ActivityPartition" (s.isInElement)
    to t : UML2!"uml::ActivityPartition" (
        name <- s.name,
        visibility <- s.visibility,
        isDimension <- s.isDimension,
        isExternal <- s.isExternal,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        node <- s.node,
        subpartition <- s.subpartition,
        represents <- s.represents,
        edge <- s.edge)
}

rule InterruptibleActivityRegion {
    from s : UML2!"uml::InterruptibleActivityRegion" (s.isInElement)
    to t : UML2!"uml::InterruptibleActivityRegion" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        node <- s.node,
        interruptingEdge <- s.interruptingEdge)
}

rule ExceptionHandler {
    from s : UML2!"uml::ExceptionHandler" (s.isInElement)
    to t : UML2!"uml::ExceptionHandler" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        handlerBody <- s.handlerBody,
        exceptionInput <- s.exceptionInput,
        exceptionType <- s.exceptionType)
}

rule OutputPin {
    from s : UML2!"uml::OutputPin" (s.isInElement)
    to t : UML2!"uml::OutputPin" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule Pin {
    from s : UML2!"uml::Pin" (
		if s.oclIsTypeOf(UML2!"uml::Pin") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Pin" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule InputPin {
    from s : UML2!"uml::InputPin" (
		if s.oclIsTypeOf(UML2!"uml::InputPin") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::InputPin" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule SendSignalAction {
    from s : UML2!"uml::SendSignalAction" (s.isInElement)
    to t : UML2!"uml::SendSignalAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        target <- s.target,
        signal <- s.signal)
}

rule CallOperationAction {
    from s : UML2!"uml::CallOperationAction" (s.isInElement)
    to t : UML2!"uml::CallOperationAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isSynchronous <- s.isSynchronous,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        result <- s.result,
        operation <- s.operation,
        target <- s.target)
}

rule CallBehaviorAction {
    from s : UML2!"uml::CallBehaviorAction" (s.isInElement)
    to t : UML2!"uml::CallBehaviorAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isSynchronous <- s.isSynchronous,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        result <- s.result,
        behavior <- s.behavior)
}

rule SequenceNode {
    from s : UML2!"uml::SequenceNode" (s.isInElement)
    to t : UML2!"uml::SequenceNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        executableNode <- s.executableNode)
}

rule ControlFlow {
    from s : UML2!"uml::ControlFlow" (s.isInElement)
    to t : UML2!"uml::ControlFlow" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        source <- s.source,
        target <- s.target,
        redefinedEdge <- s.redefinedEdge,
        inPartition <- s.inPartition,
        guard <- s.guard,
        weight <- s.weight,
        interrupts <- s.interrupts)
}

rule InitialNode {
    from s : UML2!"uml::InitialNode" (s.isInElement)
    to t : UML2!"uml::InitialNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule ActivityParameterNode {
    from s : UML2!"uml::ActivityParameterNode" (s.isInElement)
    to t : UML2!"uml::ActivityParameterNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        parameter <- s.parameter)
}

rule ValuePin {
    from s : UML2!"uml::ValuePin" (s.isInElement)
    to t : UML2!"uml::ValuePin" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        value <- s.value)
}

rule Message {
    from s : UML2!"uml::Message" (s.isInElement)
    to t : UML2!"uml::Message" (
        name <- s.name,
        visibility <- s.visibility,
        messageSort <- s.messageSort,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        receiveEvent <- s.receiveEvent,
        sendEvent <- s.sendEvent,
        connector <- s.connector,
        argument <- s.argument)
}

rule Interaction {
    from s : UML2!"uml::Interaction" (s.isInElement)
    to t : UML2!"uml::Interaction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isReentrant <- s.isReentrant,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        redefinedBehavior <- s.redefinedBehavior,
        ownedParameter <- s.ownedParameter,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        ownedParameterSet <- s.ownedParameterSet,
        specification <- s.specification,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        lifeline <- s.lifeline,
        fragment <- s.fragment,
        action <- s.action,
        formalGate <- s.formalGate,
        message <- s.message)
}

rule Lifeline {
    from s : UML2!"uml::Lifeline" (s.isInElement)
    to t : UML2!"uml::Lifeline" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        represents <- s.represents,
        selector <- s.selector,
        decomposedAs <- s.decomposedAs,
        coveredBy <- s.coveredBy)
}

rule PartDecomposition {
    from s : UML2!"uml::PartDecomposition" (s.isInElement)
    to t : UML2!"uml::PartDecomposition" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        refersTo <- s.refersTo,
        actualGate <- s.actualGate,
        argument <- s.argument)
}

rule InteractionUse {
    from s : UML2!"uml::InteractionUse" (
		if s.oclIsTypeOf(UML2!"uml::InteractionUse") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::InteractionUse" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        refersTo <- s.refersTo,
        actualGate <- s.actualGate,
        argument <- s.argument)
}

rule Gate {
    from s : UML2!"uml::Gate" (s.isInElement)
    to t : UML2!"uml::Gate" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        message <- s.message)
}

rule GeneralOrdering {
    from s : UML2!"uml::GeneralOrdering" (s.isInElement)
    to t : UML2!"uml::GeneralOrdering" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        before <- s.before,
        after <- s.after)
}

rule OccurrenceSpecification {
    from s : UML2!"uml::OccurrenceSpecification" (
		if s.oclIsTypeOf(UML2!"uml::OccurrenceSpecification") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::OccurrenceSpecification" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        toBefore <- s.toBefore,
        event <- s.event,
        toAfter <- s.toAfter)
}

rule InteractionOperand {
    from s : UML2!"uml::InteractionOperand" (s.isInElement)
    to t : UML2!"uml::InteractionOperand" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        guard <- s.guard,
        fragment <- s.fragment)
}

rule InteractionConstraint {
    from s : UML2!"uml::InteractionConstraint" (s.isInElement)
    to t : UML2!"uml::InteractionConstraint" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification,
        minint <- s.minint,
        maxint <- s.maxint)
}

rule StateInvariant {
    from s : UML2!"uml::StateInvariant" (s.isInElement)
    to t : UML2!"uml::StateInvariant" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        invariant <- s.invariant)
}

rule ActionExecutionSpecification {
    from s : UML2!"uml::ActionExecutionSpecification" (s.isInElement)
    to t : UML2!"uml::ActionExecutionSpecification" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        start <- s.start,
        finish <- s.finish,
        action <- s.action)
}

rule BehaviorExecutionSpecification {
    from s : UML2!"uml::BehaviorExecutionSpecification" (s.isInElement)
    to t : UML2!"uml::BehaviorExecutionSpecification" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        start <- s.start,
        finish <- s.finish,
        behavior <- s.behavior)
}

rule ExecutionEvent {
    from s : UML2!"uml::ExecutionEvent" (s.isInElement)
    to t : UML2!"uml::ExecutionEvent" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule CreationEvent {
    from s : UML2!"uml::CreationEvent" (s.isInElement)
    to t : UML2!"uml::CreationEvent" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule DestructionEvent {
    from s : UML2!"uml::DestructionEvent" (s.isInElement)
    to t : UML2!"uml::DestructionEvent" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule SendOperationEvent {
    from s : UML2!"uml::SendOperationEvent" (s.isInElement)
    to t : UML2!"uml::SendOperationEvent" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        operation <- s.operation)
}

rule SendSignalEvent {
    from s : UML2!"uml::SendSignalEvent" (s.isInElement)
    to t : UML2!"uml::SendSignalEvent" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        signal <- s.signal)
}

rule MessageOccurrenceSpecification {
    from s : UML2!"uml::MessageOccurrenceSpecification" (s.isInElement)
    to t : UML2!"uml::MessageOccurrenceSpecification" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        toBefore <- s.toBefore,
        event <- s.event,
        toAfter <- s.toAfter,
        message <- s.message)
}

rule ExecutionOccurrenceSpecification {
    from s : UML2!"uml::ExecutionOccurrenceSpecification" (s.isInElement)
    to t : UML2!"uml::ExecutionOccurrenceSpecification" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        toBefore <- s.toBefore,
        event <- s.event,
        toAfter <- s.toAfter,
        execution <- s.execution)
}

rule ReceiveOperationEvent {
    from s : UML2!"uml::ReceiveOperationEvent" (s.isInElement)
    to t : UML2!"uml::ReceiveOperationEvent" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        operation <- s.operation)
}

rule ReceiveSignalEvent {
    from s : UML2!"uml::ReceiveSignalEvent" (s.isInElement)
    to t : UML2!"uml::ReceiveSignalEvent" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        signal <- s.signal)
}

rule Actor {
    from s : UML2!"uml::Actor" (s.isInElement)
    to t : UML2!"uml::Actor" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger)
}

rule CallEvent {
    from s : UML2!"uml::CallEvent" (s.isInElement)
    to t : UML2!"uml::CallEvent" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        operation <- s.operation)
}

rule ChangeEvent {
    from s : UML2!"uml::ChangeEvent" (s.isInElement)
    to t : UML2!"uml::ChangeEvent" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        changeExpression <- s.changeExpression)
}

rule SignalEvent {
    from s : UML2!"uml::SignalEvent" (s.isInElement)
    to t : UML2!"uml::SignalEvent" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        signal <- s.signal)
}

rule AnyReceiveEvent {
    from s : UML2!"uml::AnyReceiveEvent" (s.isInElement)
    to t : UML2!"uml::AnyReceiveEvent" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter)
}

rule ForkNode {
    from s : UML2!"uml::ForkNode" (s.isInElement)
    to t : UML2!"uml::ForkNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule FlowFinalNode {
    from s : UML2!"uml::FlowFinalNode" (s.isInElement)
    to t : UML2!"uml::FlowFinalNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule CentralBufferNode {
    from s : UML2!"uml::CentralBufferNode" (
		if s.oclIsTypeOf(UML2!"uml::CentralBufferNode") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::CentralBufferNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection)
}

rule MergeNode {
    from s : UML2!"uml::MergeNode" (s.isInElement)
    to t : UML2!"uml::MergeNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule DecisionNode {
    from s : UML2!"uml::DecisionNode" (s.isInElement)
    to t : UML2!"uml::DecisionNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        decisionInput <- s.decisionInput,
        decisionInputFlow <- s.decisionInputFlow)
}

rule ObjectFlow {
    from s : UML2!"uml::ObjectFlow" (s.isInElement)
    to t : UML2!"uml::ObjectFlow" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isMulticast <- s.isMulticast,
        isMultireceive <- s.isMultireceive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        source <- s.source,
        target <- s.target,
        redefinedEdge <- s.redefinedEdge,
        inPartition <- s.inPartition,
        guard <- s.guard,
        weight <- s.weight,
        interrupts <- s.interrupts,
        transformation <- s.transformation,
        selection <- s.selection)
}

rule ActivityFinalNode {
    from s : UML2!"uml::ActivityFinalNode" (s.isInElement)
    to t : UML2!"uml::ActivityFinalNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode)
}

rule ComponentRealization {
    from s : UML2!"uml::ComponentRealization" (s.isInElement)
    to t : UML2!"uml::ComponentRealization" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        supplier <- s.supplier,
        client <- s.client,
        mapping <- s.mapping,
        realizingClassifier <- s.realizingClassifier)
}

rule Component {
    from s : UML2!"uml::Component" (s.isInElement)
    to t : UML2!"uml::Component" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isIndirectlyInstantiated <- s.isIndirectlyInstantiated,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        packagedElement <- s.packagedElement,
        realization <- s.realization)
}

rule Node {
    from s : UML2!"uml::Node" (
		if s.oclIsTypeOf(UML2!"uml::Node") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Node" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        deployment <- s.deployment,
        nestedNode <- s.nestedNode)
}

rule CommunicationPath {
    from s : UML2!"uml::CommunicationPath" (s.isInElement)
    to t : UML2!"uml::CommunicationPath" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

rule Device {
    from s : UML2!"uml::Device" (s.isInElement)
    to t : UML2!"uml::Device" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        deployment <- s.deployment,
        nestedNode <- s.nestedNode)
}

rule ExecutionEnvironment {
    from s : UML2!"uml::ExecutionEnvironment" (s.isInElement)
    to t : UML2!"uml::ExecutionEnvironment" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        deployment <- s.deployment,
        nestedNode <- s.nestedNode)
}

rule CombinedFragment {
    from s : UML2!"uml::CombinedFragment" (
		if s.oclIsTypeOf(UML2!"uml::CombinedFragment") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::CombinedFragment" (
        name <- s.name,
        visibility <- s.visibility,
        interactionOperator <- s.interactionOperator,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        operand <- s.operand,
        cfragmentGate <- s.cfragmentGate)
}

rule Continuation {
    from s : UML2!"uml::Continuation" (s.isInElement)
    to t : UML2!"uml::Continuation" (
        name <- s.name,
        visibility <- s.visibility,
        setting <- s.setting,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering)
}

rule ConsiderIgnoreFragment {
    from s : UML2!"uml::ConsiderIgnoreFragment" (s.isInElement)
    to t : UML2!"uml::ConsiderIgnoreFragment" (
        name <- s.name,
        visibility <- s.visibility,
        interactionOperator <- s.interactionOperator,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        covered <- s.covered,
        generalOrdering <- s.generalOrdering,
        operand <- s.operand,
        cfragmentGate <- s.cfragmentGate,
        message <- s.message)
}

rule CreateObjectAction {
    from s : UML2!"uml::CreateObjectAction" (s.isInElement)
    to t : UML2!"uml::CreateObjectAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        classifier <- s.classifier,
        result <- s.result)
}

rule DestroyObjectAction {
    from s : UML2!"uml::DestroyObjectAction" (s.isInElement)
    to t : UML2!"uml::DestroyObjectAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isDestroyLinks <- s.isDestroyLinks,
        isDestroyOwnedObjects <- s.isDestroyOwnedObjects,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        target <- s.target)
}

rule TestIdentityAction {
    from s : UML2!"uml::TestIdentityAction" (s.isInElement)
    to t : UML2!"uml::TestIdentityAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        first <- s.first,
        second <- s.second,
        result <- s.result)
}

rule ReadSelfAction {
    from s : UML2!"uml::ReadSelfAction" (s.isInElement)
    to t : UML2!"uml::ReadSelfAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result)
}

rule ReadStructuralFeatureAction {
    from s : UML2!"uml::ReadStructuralFeatureAction" (s.isInElement)
    to t : UML2!"uml::ReadStructuralFeatureAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        result <- s.result)
}

rule ClearStructuralFeatureAction {
    from s : UML2!"uml::ClearStructuralFeatureAction" (s.isInElement)
    to t : UML2!"uml::ClearStructuralFeatureAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        result <- s.result)
}

rule RemoveStructuralFeatureValueAction {
    from s : UML2!"uml::RemoveStructuralFeatureValueAction" (s.isInElement)
    to t : UML2!"uml::RemoveStructuralFeatureValueAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isRemoveDuplicates <- s.isRemoveDuplicates,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        value <- s.value,
        result <- s.result,
        removeAt <- s.removeAt)
}

rule AddStructuralFeatureValueAction {
    from s : UML2!"uml::AddStructuralFeatureValueAction" (s.isInElement)
    to t : UML2!"uml::AddStructuralFeatureValueAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        structuralFeature <- s.structuralFeature,
        object <- s.object,
        value <- s.value,
        result <- s.result,
        insertAt <- s.insertAt)
}

rule LinkEndData {
    from s : UML2!"uml::LinkEndData" (
		if s.oclIsTypeOf(UML2!"uml::LinkEndData") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::LinkEndData" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        value <- s.value,
        end <- s.end,
        qualifier <- s.qualifier)
}

rule QualifierValue {
    from s : UML2!"uml::QualifierValue" (s.isInElement)
    to t : UML2!"uml::QualifierValue" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        qualifier <- s.qualifier,
        value <- s.value)
}

rule ReadLinkAction {
    from s : UML2!"uml::ReadLinkAction" (s.isInElement)
    to t : UML2!"uml::ReadLinkAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue,
        result <- s.result)
}

rule LinkEndCreationData {
    from s : UML2!"uml::LinkEndCreationData" (s.isInElement)
    to t : UML2!"uml::LinkEndCreationData" (
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        value <- s.value,
        end <- s.end,
        qualifier <- s.qualifier,
        insertAt <- s.insertAt)
}

rule CreateLinkAction {
    from s : UML2!"uml::CreateLinkAction" (
		if s.oclIsTypeOf(UML2!"uml::CreateLinkAction") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::CreateLinkAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue)
}

rule DestroyLinkAction {
    from s : UML2!"uml::DestroyLinkAction" (s.isInElement)
    to t : UML2!"uml::DestroyLinkAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue)
}

rule LinkEndDestructionData {
    from s : UML2!"uml::LinkEndDestructionData" (s.isInElement)
    to t : UML2!"uml::LinkEndDestructionData" (
        isDestroyDuplicates <- s.isDestroyDuplicates,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        value <- s.value,
        end <- s.end,
        qualifier <- s.qualifier,
        destroyAt <- s.destroyAt)
}

rule ClearAssociationAction {
    from s : UML2!"uml::ClearAssociationAction" (s.isInElement)
    to t : UML2!"uml::ClearAssociationAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object,
        association <- s.association)
}

rule BroadcastSignalAction {
    from s : UML2!"uml::BroadcastSignalAction" (s.isInElement)
    to t : UML2!"uml::BroadcastSignalAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        signal <- s.signal)
}

rule SendObjectAction {
    from s : UML2!"uml::SendObjectAction" (s.isInElement)
    to t : UML2!"uml::SendObjectAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        target <- s.target,
        request <- s.request)
}

rule ValueSpecificationAction {
    from s : UML2!"uml::ValueSpecificationAction" (s.isInElement)
    to t : UML2!"uml::ValueSpecificationAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        value <- s.value,
        result <- s.result)
}

rule TimeExpression {
    from s : UML2!"uml::TimeExpression" (s.isInElement)
    to t : UML2!"uml::TimeExpression" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        expr <- s.expr,
        observation <- s.observation)
}

rule Duration {
    from s : UML2!"uml::Duration" (s.isInElement)
    to t : UML2!"uml::Duration" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        expr <- s.expr,
        observation <- s.observation)
}

rule DurationInterval {
    from s : UML2!"uml::DurationInterval" (s.isInElement)
    to t : UML2!"uml::DurationInterval" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        min <- s.min,
        max <- s.max)
}

rule Interval {
    from s : UML2!"uml::Interval" (
		if s.oclIsTypeOf(UML2!"uml::Interval") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::Interval" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        min <- s.min,
        max <- s.max)
}

rule TimeConstraint {
    from s : UML2!"uml::TimeConstraint" (s.isInElement)
    to t : UML2!"uml::TimeConstraint" (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule IntervalConstraint {
    from s : UML2!"uml::IntervalConstraint" (
		if s.oclIsTypeOf(UML2!"uml::IntervalConstraint") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::IntervalConstraint" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule TimeInterval {
    from s : UML2!"uml::TimeInterval" (s.isInElement)
    to t : UML2!"uml::TimeInterval" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        type <- s.type,
        min <- s.min,
        max <- s.max)
}

rule DurationConstraint {
    from s : UML2!"uml::DurationConstraint" (s.isInElement)
    to t : UML2!"uml::DurationConstraint" (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        constrainedElement <- s.constrainedElement,
        specification <- s.specification)
}

rule TimeObservation {
    from s : UML2!"uml::TimeObservation" (s.isInElement)
    to t : UML2!"uml::TimeObservation" (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        event <- s.event)
}

rule DurationObservation {
    from s : UML2!"uml::DurationObservation" (s.isInElement)
    to t : UML2!"uml::DurationObservation" (
        name <- s.name,
        visibility <- s.visibility,
        firstEvent <- s.firstEvent,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        event <- s.event)
}

rule FinalState {
    from s : UML2!"uml::FinalState" (s.isInElement)
    to t : UML2!"uml::FinalState" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        submachine <- s.submachine,
        connection <- s.connection,
        connectionPoint <- s.connectionPoint,
        redefinedState <- s.redefinedState,
        stateInvariant <- s.stateInvariant,
        entry <- s.entry,
        exit <- s.exit,
        doActivity <- s.doActivity,
        deferrableTrigger <- s.deferrableTrigger,
        region <- s.region)
}

rule TimeEvent {
    from s : UML2!"uml::TimeEvent" (s.isInElement)
    to t : UML2!"uml::TimeEvent" (
        name <- s.name,
        visibility <- s.visibility,
        isRelative <- s.isRelative,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        when <- s.when)
}

rule ReadVariableAction {
    from s : UML2!"uml::ReadVariableAction" (s.isInElement)
    to t : UML2!"uml::ReadVariableAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        result <- s.result)
}

rule ClearVariableAction {
    from s : UML2!"uml::ClearVariableAction" (s.isInElement)
    to t : UML2!"uml::ClearVariableAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable)
}

rule AddVariableValueAction {
    from s : UML2!"uml::AddVariableValueAction" (s.isInElement)
    to t : UML2!"uml::AddVariableValueAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        value <- s.value,
        insertAt <- s.insertAt)
}

rule RemoveVariableValueAction {
    from s : UML2!"uml::RemoveVariableValueAction" (s.isInElement)
    to t : UML2!"uml::RemoveVariableValueAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isRemoveDuplicates <- s.isRemoveDuplicates,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        variable <- s.variable,
        value <- s.value,
        removeAt <- s.removeAt)
}

rule RaiseExceptionAction {
    from s : UML2!"uml::RaiseExceptionAction" (s.isInElement)
    to t : UML2!"uml::RaiseExceptionAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        exception <- s.exception)
}

rule ActionInputPin {
    from s : UML2!"uml::ActionInputPin" (s.isInElement)
    to t : UML2!"uml::ActionInputPin" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isControl <- s.isControl,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        fromAction <- s.fromAction)
}

rule InformationItem {
    from s : UML2!"uml::InformationItem" (s.isInElement)
    to t : UML2!"uml::InformationItem" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        represented <- s.represented)
}

rule InformationFlow {
    from s : UML2!"uml::InformationFlow" (s.isInElement)
    to t : UML2!"uml::InformationFlow" (
        name <- s.name,
        visibility <- s.visibility,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        templateParameter <- s.templateParameter,
        realization <- s.realization,
        conveyed <- s.conveyed,
        informationSource <- s.informationSource,
        informationTarget <- s.informationTarget,
        realizingActivityEdge <- s.realizingActivityEdge,
        realizingConnector <- s.realizingConnector,
        realizingMessage <- s.realizingMessage)
}

rule ReadExtentAction {
    from s : UML2!"uml::ReadExtentAction" (s.isInElement)
    to t : UML2!"uml::ReadExtentAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        classifier <- s.classifier)
}

rule ReclassifyObjectAction {
    from s : UML2!"uml::ReclassifyObjectAction" (s.isInElement)
    to t : UML2!"uml::ReclassifyObjectAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isReplaceAll <- s.isReplaceAll,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        oldClassifier <- s.oldClassifier,
        newClassifier <- s.newClassifier,
        object <- s.object)
}

rule ReadIsClassifiedObjectAction {
    from s : UML2!"uml::ReadIsClassifiedObjectAction" (s.isInElement)
    to t : UML2!"uml::ReadIsClassifiedObjectAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isDirect <- s.isDirect,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        classifier <- s.classifier,
        result <- s.result,
        object <- s.object)
}

rule StartClassifierBehaviorAction {
    from s : UML2!"uml::StartClassifierBehaviorAction" (s.isInElement)
    to t : UML2!"uml::StartClassifierBehaviorAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object)
}

rule ReadLinkObjectEndAction {
    from s : UML2!"uml::ReadLinkObjectEndAction" (s.isInElement)
    to t : UML2!"uml::ReadLinkObjectEndAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object,
        end <- s.end,
        result <- s.result)
}

rule ReadLinkObjectEndQualifierAction {
    from s : UML2!"uml::ReadLinkObjectEndQualifierAction" (s.isInElement)
    to t : UML2!"uml::ReadLinkObjectEndQualifierAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        object <- s.object,
        result <- s.result,
        qualifier <- s.qualifier)
}

rule CreateLinkObjectAction {
    from s : UML2!"uml::CreateLinkObjectAction" (s.isInElement)
    to t : UML2!"uml::CreateLinkObjectAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        endData <- s.endData,
        inputValue <- s.inputValue,
        result <- s.result)
}

rule AcceptEventAction {
    from s : UML2!"uml::AcceptEventAction" (
		if s.oclIsTypeOf(UML2!"uml::AcceptEventAction") then
			s.isInElement
		else false endif)
    to t : UML2!"uml::AcceptEventAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isUnmarshall <- s.isUnmarshall,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        trigger <- s.trigger)
}

rule AcceptCallAction {
    from s : UML2!"uml::AcceptCallAction" (s.isInElement)
    to t : UML2!"uml::AcceptCallAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isUnmarshall <- s.isUnmarshall,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        trigger <- s.trigger,
        returnInformation <- s.returnInformation)
}

rule ReplyAction {
    from s : UML2!"uml::ReplyAction" (s.isInElement)
    to t : UML2!"uml::ReplyAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        replyToCall <- s.replyToCall,
        returnInformation <- s.returnInformation,
        replyValue <- s.replyValue)
}

rule UnmarshallAction {
    from s : UML2!"uml::UnmarshallAction" (s.isInElement)
    to t : UML2!"uml::UnmarshallAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        result <- s.result,
        unmarshallType <- s.unmarshallType,
        object <- s.object)
}

rule ReduceAction {
    from s : UML2!"uml::ReduceAction" (s.isInElement)
    to t : UML2!"uml::ReduceAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isOrdered <- s.isOrdered,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        reducer <- s.reducer,
        result <- s.result,
        collection <- s.collection)
}

rule StartObjectBehaviorAction {
    from s : UML2!"uml::StartObjectBehaviorAction" (s.isInElement)
    to t : UML2!"uml::StartObjectBehaviorAction" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isSynchronous <- s.isSynchronous,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        argument <- s.argument,
        onPort <- s.onPort,
        result <- s.result,
        object <- s.object)
}

rule JoinNode {
    from s : UML2!"uml::JoinNode" (s.isInElement)
    to t : UML2!"uml::JoinNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isCombineDuplicate <- s.isCombineDuplicate,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        joinSpec <- s.joinSpec)
}

rule DataStoreNode {
    from s : UML2!"uml::DataStoreNode" (s.isInElement)
    to t : UML2!"uml::DataStoreNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection)
}

rule ConditionalNode {
    from s : UML2!"uml::ConditionalNode" (s.isInElement)
    to t : UML2!"uml::ConditionalNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        isDeterminate <- s.isDeterminate,
        isAssured <- s.isAssured,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        clause <- s.clause,
        result <- s.result)
}

rule Clause {
    from s : UML2!"uml::Clause" (s.isInElement)
    to t : UML2!"uml::Clause" (
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        test <- s.test,
        body <- s.body,
        predecessorClause <- s.predecessorClause,
        successorClause <- s.successorClause,
        decider <- s.decider,
        bodyOutput <- s.bodyOutput)
}

rule LoopNode {
    from s : UML2!"uml::LoopNode" (s.isInElement)
    to t : UML2!"uml::LoopNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        isTestedFirst <- s.isTestedFirst,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        bodyPart <- s.bodyPart,
        setupPart <- s.setupPart,
        decider <- s.decider,
        test <- s.test,
        result <- s.result,
        loopVariable <- s.loopVariable,
        bodyOutput <- s.bodyOutput,
        loopVariableInput <- s.loopVariableInput)
}

rule ExpansionNode {
    from s : UML2!"uml::ExpansionNode" (s.isInElement)
    to t : UML2!"uml::ExpansionNode" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        ordering <- s.ordering,
        isControlType <- s.isControlType,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        type <- s.type,
        upperBound <- s.upperBound,
        inState <- s.inState,
        selection <- s.selection,
        regionAsOutput <- s.regionAsOutput,
        regionAsInput <- s.regionAsInput)
}

rule ExpansionRegion {
    from s : UML2!"uml::ExpansionRegion" (s.isInElement)
    to t : UML2!"uml::ExpansionRegion" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        mustIsolate <- s.mustIsolate,
        mode <- s.mode,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        outgoing <- s.outgoing,
        incoming <- s.incoming,
        inPartition <- s.inPartition,
        inInterruptibleRegion <- s.inInterruptibleRegion,
        redefinedNode <- s.redefinedNode,
        handler <- s.handler,
        localPrecondition <- s.localPrecondition,
        localPostcondition <- s.localPostcondition,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        variable <- s.variable,
        edge <- s.edge,
        node <- s.node,
        inputElement <- s.inputElement,
        outputElement <- s.outputElement)
}

rule ProtocolTransition {
    from s : UML2!"uml::ProtocolTransition" (s.isInElement)
    to t : UML2!"uml::ProtocolTransition" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        kind <- s.kind,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        source <- s.source,
        target <- s.target,
        redefinedTransition <- s.redefinedTransition,
        guard <- s.guard,
        effect <- s.effect,
        trigger <- s.trigger,
        postCondition <- s.postCondition,
        preCondition <- s.preCondition)
}

rule AssociationClass {
    from s : UML2!"uml::AssociationClass" (s.isInElement)
    to t : UML2!"uml::AssociationClass" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        isDerived <- s.isDerived,
        eAnnotations <- s.eAnnotations,
        ownedComment <- s.ownedComment,
        clientDependency <- s.clientDependency,
        nameExpression <- s.nameExpression,
        elementImport <- s.elementImport,
        packageImport <- s.packageImport,
        ownedRule <- s.ownedRule,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization,
        powertypeExtent <- s.powertypeExtent,
        redefinedClassifier <- s.redefinedClassifier,
        substitution <- s.substitution,
        representation <- s.representation,
        collaborationUse <- s.collaborationUse,
        ownedUseCase <- s.ownedUseCase,
        useCase <- s.useCase,
        ownedAttribute <- s.ownedAttribute,
        ownedConnector <- s.ownedConnector,
        ownedBehavior <- s.ownedBehavior,
        classifierBehavior <- s.classifierBehavior,
        interfaceRealization <- s.interfaceRealization,
        ownedTrigger <- s.ownedTrigger,
        nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation,
        ownedReception <- s.ownedReception,
        ownedEnd <- s.ownedEnd,
        memberEnd <- s.memberEnd,
        navigableOwnedEnd <- s.navigableOwnedEnd)
}

-- ======================================================================
-- UML2 copying rules end
-- ======================================================================

-- work around superimposition bug that does not add a new endpoint rule
endpoint rule End() {
	do {
	}
}
