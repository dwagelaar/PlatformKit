-- @atlcompiler atl2006
-- $Id:UML2Comparison.atl 7084 2007-07-10 13:19:05Z dwagelaa $
-- Library for comparing a UML2 model to other versions of the UML2 model
library UML2Comparison;

uses UML2;

-- ======================================================================
-- helper attributes begin
-- ======================================================================

helper def : UML2ComparisonVersionString : String =
	'$Id$';

-- All Package instances
helper def : allPackages : Set(UML2!"uml::Package") = 
	UML2!"uml::Package".allInstances();

-- Name of the first Model in IN
helper def : modelName : String =
	UML2!"uml::Model".allInstancesFrom('IN')->asSequence()->first().name;

-- ======================================================================
-- general context helper attributes begin
-- ======================================================================

-- ------------------------ prefix --------------------------------------

helper context String def : prefix : String =
	'[' + self + '] ';

-- ------------------------ umlQualifiedName ----------------------------

-- The UML '::' separated qualified name for elements that are
-- contained in a Package (exact) or a Classifier, the simple name otherwise.
helper context UML2!"uml::NamedElement" def : umlQualifiedName : String =
	if self.oclIsKindOf(UML2!"uml::Feature") then
		self.name
	else
		if self.owner.oclIsTypeOf(UML2!"uml::Package") or self.owner.oclIsKindOf(UML2!"uml::Classifier") then
			self.owner.umlQualifiedName + '::' + self.name
		else
			self.name
		endif
	endif;

-- ------------------------ allOwnedPackages ----------------------------

-- The transitive closure of contained Packages, excluding inferred packages.
helper context UML2!"uml::Package" def : allOwnedPackages : Sequence(UML2!"uml::Package") =
	self.allOwnedElements()
		->reject(e|e.isInferred)
		->select(o|o.oclIsKindOf(UML2!"uml::Package"));

-- ------------------------ allOwnedClassifiers -------------------------

-- The transitive closure of contained Classifiers, excluding inferred and derived Classifiers.
helper context UML2!"uml::Package" def : allOwnedClassifiers : Sequence(UML2!"uml::Classifier") =
	self.allOwnedElements()
		->reject(e|e.isInferred)
		->select(o|o.oclIsKindOf(UML2!"uml::Classifier"))
		->select(c|c.getNearestPackage() = self);

-- The transitive closure of contained Classifiers, excluding inferred and derived Classifiers.
helper context UML2!"uml::Classifier" def : allOwnedClassifiers : Sequence(UML2!"uml::Classifier") =
	self.allOwnedElements()
		->reject(e|e.isInferred)
		->select(o|o.oclIsKindOf(UML2!"uml::Classifier"));

-- ------------------------ myOclType -----------------------------------

-- Same as oclType(), except DataType becomes Classifier.
-- Jar2UML uses DataType to represent inferred Classifier instances
-- of which it isn't known whether they are Classes or Interfaces.
helper context UML2!"uml::Element" def : myOclType : OclType =
	let type : OclType = self.oclType()
	in if type = UML2!"uml::DataType"
	   then UML2!"uml::Classifier"
	   else type endif;

-- ------------------------ isInferred ----------------------------------

-- Looks up isInferred at its container.
helper context UML2!"ecore::EObject" def : objectIsInferred : Boolean =
	let owner : UML2!"ecore::EObject" = self.refImmediateComposite() in
	if owner.oclIsUndefined() then false else
		owner.isInferred
	endif;

-- True iff self or its container is annotated with an inferred tag.
helper context UML2!"ecore::EObject" def : isInferred : Boolean =
	self.objectIsInferred;

-- True iff self or its container is annotated with an inferred tag.
helper context UML2!"ecore::EModelElement" def : isInferred : Boolean =
	let ann : UML2!"ecore::EAnnotation" = self.getEAnnotation('Jar2UML') in
	if ann.oclIsUndefined() then self.objectIsInferred
	else
		if ann.details->exists(d|d.key='inferred' and d.value='true') then true
		else self.objectIsInferred endif
	endif;

-- ------------------------ allOther --------------------------------------

-- All Models except self.
helper context UML2!"uml::Model" def : allOther : Sequence(UML2!"uml::Model") =
	thisModule.allPackages
		->reject(p|p=self)
		->select(p|p.oclIsKindOf(UML2!"uml::Model"));

-- All Packages except self.
helper context UML2!"uml::Package" def : allOther : Sequence(UML2!"uml::Package") =
	thisModule.allPackages
		->reject(p|p=self);

-- ======================================================================
-- helper attributes for determining compatibility
-- ======================================================================

-- ------------------------ suppliers -----------------------------------
	
-- Named Dependency suppliers and extended Interfaces.
helper context UML2!"uml::Interface" def : suppliers : Set(UML2!"uml::NamedElement") =
	self.clientDependency->collect(d|d.supplier
			->select(n|not n.name.oclIsUndefined())
		)->flatten()->asSet()
	->union(self.general);

-- Named Dependency suppliers.
helper context UML2!"uml::NamedElement" def : suppliers : Set(UML2!"uml::NamedElement") =
	self.clientDependency->collect(d|d.supplier
			->select(n|not n.name.oclIsUndefined())
		)->flatten()->asSet();

-- ------------------------ allSuppliers --------------------------------

-- Transitive closure of named Dependency suppliers.
helper context UML2!"uml::NamedElement" def : allSuppliers : Set(UML2!"uml::NamedElement") =
	self.suppliers->union(
		self.suppliers->collect(s|s.allSuppliers)->flatten())->asSet();

-- ------------------------ allFeatures ---------------------------------

-- All features of self, including any inherited or interface features.
helper context UML2!"uml::Classifier" def : allFeatures : Set(UML2!"uml::Feature") =
	self.feature
		->union(self.general
			->collect(c|c.allFeatures)->flatten()->asSet())
		->union(self.suppliers
			->select(s|s.oclIsKindOf(UML2!"uml::Classifier"))
			->collect(c|c.allFeatures)->flatten()->asSet());

-- ------------------------ owlClassesInPrev ----------------------------

-- All OWLClasses that represent self (usually only one).
helper context UML2!"uml::NamedElement" def : owlClassesInPrev : Sequence(OWL!"owl::OWLClass") =
	OWL!"owl::OWLClass".allInstances()
		->select(c|c.localName = self.ontClassName + 'Library')
		->select(o|o.namespace.name = self.getModel().name);

-- ------------------------ compatibleInPrev ----------------------------

-- All Models X other than self for which self is compatible with X.
helper context UML2!"uml::Model" def : compatibleInPrev : Sequence(UML2!"uml::Model") =
	self.allOther
		->select(m|self.hasAllPackagesCompatibleWith(m))
		.debug(thisModule.modelName.prefix + self.qualifiedName + ' compatible models');

-- All Packages X other than self for which self is compatible with X
helper context UML2!"uml::Package" def : compatibleInPrev : Sequence(UML2!"uml::Package") =
	self.locallyCompatibleInPrev
		->select(p|self.hasElementsCompatibleWith(p))
		.debug(thisModule.modelName.prefix + self.qualifiedName + ' compatible packages');

-- All Classifiers X other than self for which self is compatible with X.
helper context UML2!"uml::Classifier" def : compatibleInPrev : Sequence(UML2!"uml::Classifier") =
	self.locallyCompatibleInPrev
		->select(c|self.isCompatibleWith(c));

-- ------------------------ equivalentInPrev ----------------------------

-- All Models X other than self for which self is equivalent with X.
helper context UML2!"uml::Model" def : equivalentInPrev : Sequence(UML2!"uml::Model") =
	self.allOther
		->select(m|self.hasAllPackagesEquivalentWith(m))
		.debug(thisModule.modelName.prefix + self.qualifiedName + ' equivalent models');

-- All Packages X other than self for which self is equivalent with X
helper context UML2!"uml::Package" def : equivalentInPrev : Sequence(UML2!"uml::Package") =
	self.compatibleInPrev->select(p|p.isCompatibleWith(self))
		.debug(thisModule.modelName.prefix + self.qualifiedName + ' equivalent packages');

-- All Classifiers X other than self for which self is compatible with X and X is compatible with self.
helper context UML2!"uml::Classifier" def : equivalentInPrev : Sequence(UML2!"uml::Classifier") =
	self.compatibleInPrev->select(c|c.isCompatibleWith(self));

-- ------------------------ locallyCompatibleInPrev ---------------------

-- All Packages X other than self for which self is locally compatible with X,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::Package" def : locallyCompatibleInPrev : Sequence(UML2!"uml::Package") =
	self.allOther
		->reject(e|e.isInferred)
		->select(p|self.isLocallyCompatibleWith(p));

-- All Classifiers X other than self for which self is locally compatible with X,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::Classifier" def : locallyCompatibleInPrev : Sequence(UML2!"uml::Classifier") =
	self.getNearestPackage().locallyCompatibleInPrev
		->collect(p1|p1.allOwnedClassifiers)->flatten()
		->select(c|self.isLocallyCompatibleWith(c));

-- ======================================================================
-- helper attributes end
-- ======================================================================

-- ======================================================================
-- helper methods for determining compatibility
-- ======================================================================

-- ------------------------ allPackagesLocallyIncompatibleWith ----------

-- All Packages X contained in m for which self does not contain
-- a Package that is locally compatible with X,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::Model" def : allPackagesLocallyIncompatibleWith(m : UML2!"uml::Model") : Sequence(UML2!"uml::Package") =
	m.allOwnedPackages->select(p|not self.hasPackageLocallyCompatibleWith(p));
		
-- ------------------------ allPackagesIncompatibleWith -----------------

-- All Packages X contained in m for which self does not contain
-- a Package that is compatible with X.
helper context UML2!"uml::Model" def : allPackagesIncompatibleWith(m : UML2!"uml::Model") : Sequence(UML2!"uml::Package") =
	m.allOwnedPackages->select(p|not self.hasPackageCompatibleWith(p));

-- ------------------------ hasAllPackagesCompatibleWith ----------------

-- True iff for all Packages X contained in m, self has a Package Y that is compatible with X.
helper context UML2!"uml::Model" def : hasAllPackagesCompatibleWith(m : UML2!"uml::Model") : Boolean =
	let compPackages : Sequence(UML2!"uml::Package") = self.allPackagesIncompatibleWith(m)
	in if compPackages->isEmpty() then true
	   else compPackages.debug(thisModule.modelName.prefix + self.qualifiedName + ' misses packages compatible with ')->isEmpty() endif;

-- ------------------------ hasAllPackagesEquivalentWith ----------------

-- True iff for all Packages X contained in m, self has a Package Y that is equivalent with X.
helper context UML2!"uml::Model" def : hasAllPackagesEquivalentWith(m : UML2!"uml::Model") : Boolean =
	let equivPackages : Sequence(UML2!"uml::Package") = m.allOwnedPackages
		->select(p|not self.hasPackageEquivalentWith(p))
	in if equivPackages->isEmpty() then true
	   else equivPackages.debug(thisModule.modelName.prefix + self.qualifiedName + ' misses packages equivalent with ')->isEmpty() endif;

-- ------------------------ hasPackageLocallyCompatibleWith -----------

-- True iff self (transitively) contains a Package that is locally compatible with p,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::Model" def : hasPackageLocallyCompatibleWith(p : UML2!"uml::Package") : Boolean =
	self.allOwnedPackages
		->exists(sp|sp.locallyCompatibleInPrev->includes(p));

-- ------------------------ hasPackageCompatibleWith --------------------

-- True iff self (transitively) contains a Package that is compatible with p.
helper context UML2!"uml::Model" def : hasPackageCompatibleWith(p : UML2!"uml::Package") : Boolean =
	self.allOwnedPackages
		->exists(sp|sp.compatibleInPrev->includes(p));

-- ------------------------ hasPackageEquivalentWith --------------------

-- True iff self (transitively) contains a Package that is equivalent with p.
helper context UML2!"uml::Model" def : hasPackageEquivalentWith(p : UML2!"uml::Package") : Boolean =
	self.allOwnedPackages
		->select(sp|sp.equivalentInPrev->includes(p))->notEmpty();

-- ------------------------ isCompatibleWith ----------------------------

-- True iff self is compatible with e.
helper context UML2!"uml::NamedElement" def : isCompatibleWith(e : UML2!"uml::NamedElement") : Boolean =
	if self.isLocallyCompatibleWith(e) then
		self.hasElementsCompatibleWith(e)
	else false endif;

-- ------------------------ isLocallyCompatibleWith ---------------------

-- True iff self is locally compatible with p,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::Package" def : isLocallyCompatibleWith(p : UML2!"uml::Package") : Boolean =
	self.namedElementIsLocallyCompatibleWith(p);

-- True iff self is locally compatible with c,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::Classifier" def : isLocallyCompatibleWith(c : UML2!"uml::Classifier") : Boolean =
	if self.namedElementIsLocallyCompatibleWith(c) then
		self.isAbstract implies c.isAbstract
	else false endif;

-- True iff self is locally compatible with f,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::StructuralFeature" def : isLocallyCompatibleWith(f : UML2!"uml::StructuralFeature") : Boolean =
	if self.typedElementIsLocallyCompatibleWith(f)
	then (self.isStatic = f.isStatic) and
		 (self.isReadOnly implies f.isReadOnly) and
		 (self.isLeaf implies f.isLeaf)
	else false endif;

-- True iff self is locally compatible with f,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::BehavioralFeature" def : isLocallyCompatibleWith(f : UML2!"uml::BehavioralFeature") : Boolean =
	if self.namedElementIsLocallyCompatibleWith(f)
	then (self.isStatic = f.isStatic) and
		 (self.isAbstract implies f.isAbstract) and
		 (self.isLeaf implies f.isLeaf)
	else false endif;

-- True iff self is locally compatible with p,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::Parameter" def : isLocallyCompatibleWith(p : UML2!"uml::Parameter") : Boolean =
	if p.oclIsUndefined() then false
	else
		if self.typedElementIsLocallyCompatibleWith(p)
		then (self.direction = p.direction)
		else false endif
	endif;

-- True iff self is locally compatible with t,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::TypedElement" def : isLocallyCompatibleWith(t : UML2!"uml::TypedElement") : Boolean =
	self.typedElementIsLocallyCompatibleWith(t);
	
-- True iff self is locally compatible with e,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::NamedElement" def : isLocallyCompatibleWith(e : UML2!"uml::NamedElement") : Boolean =
	self.namedElementIsLocallyCompatibleWith(e);

-- Reusable isLocallyCompatibleWith helper for all TypedElements.
helper context UML2!"uml::TypedElement" def : typedElementIsLocallyCompatibleWith(t : UML2!"uml::TypedElement") : Boolean =
	if self.namedElementIsLocallyCompatibleWith(t)
	then if self.type.oclIsUndefined()
		 then t.type.oclIsUndefined()
		 else if t.type.oclIsUndefined()
		 	  then false
			  else (self.type.umlQualifiedName = t.type.umlQualifiedName) endif endif
	else false endif;
	
-- Reusable isLocallyCompatibleWith helper for all NamedElements.
helper context UML2!"uml::NamedElement" def : namedElementIsLocallyCompatibleWith(e : UML2!"uml::NamedElement") : Boolean =
	if (self.umlQualifiedName = e.umlQualifiedName) then
		(self.myOclType.conformsTo(e.myOclType)) and (self.visibilityIsCompatibleWith(e))
	else false endif;

-- ------------------------ hasElementsCompatibleWith -------------------

-- True iff for all elements X contained by p there exists an element Y contained by self
-- that is compatible with X.
helper context UML2!"uml::Package" def : hasElementsCompatibleWith(p : UML2!"uml::Package") : Boolean =
	if self.namedElementHasElementsCompatibleWith(p)
	then (let compClassifiers : Sequence(UML2!"uml::Classifier") = p.allOwnedClassifiers->select(c|not self.hasOwnedClassifierCompatibleWith(c))
		  in if compClassifiers->isEmpty() then true
		  	 else compClassifiers.debug(thisModule.modelName.prefix + self.qualifiedName + ' misses classifiers compatible with ')->isEmpty() endif)
	else false endif;

-- True iff for all elements X contained by c there exists an element Y contained by self
-- that is compatible with X.
helper context UML2!"uml::Classifier" def : hasElementsCompatibleWith(c : UML2!"uml::Classifier") : Boolean =
	if self.namedElementHasElementsCompatibleWith(c) then
		if (let compGenerals : Sequence(UML2!"uml::Classifier") = self.allGeneralsIncompatibleWith(c)
			in if compGenerals->isEmpty() then true
			   else compGenerals.debug(thisModule.modelName.prefix + self.qualifiedName + ' misses generals compatible with ')->isEmpty() endif)
		then (let compFeatures : Sequence(UML2!"uml::Feature") = self.allFeaturesIncompatibleWith(c)
			  in if compFeatures->isEmpty() then true
			  	 else compFeatures.debug(thisModule.modelName.prefix + self.qualifiedName + ' misses features compatible with ')->isEmpty() endif)
		else false endif
	else false endif;

-- True iff for all elements X contained by f there exists an element Y contained by self
-- that is compatible with X.
helper context UML2!"uml::StructuralFeature" def : hasElementsCompatibleWith(f : UML2!"uml::StructuralFeature") : Boolean =
	self.typedElementHasElementsCompatibleWith(f);

-- True iff for all elements X contained by f there exists an element Y contained by self
-- that is compatible with X.
helper context UML2!"uml::BehavioralFeature" def : hasElementsCompatibleWith(f : UML2!"uml::BehavioralFeature") : Boolean =
	if self.namedElementHasElementsCompatibleWith(f)
	then if (self.ownedParameter->size() = f.ownedParameter->size())
		 then thisModule.compatibleParameters(self.ownedParameter, f.ownedParameter)
		 else false endif
	else false endif;

-- True iff for all elements X contained by p there exists an element Y contained by self
-- that is compatible with X.
helper context UML2!"uml::Parameter" def : hasElementsCompatibleWith(p : UML2!"uml::Parameter") : Boolean =
	self.typedElementHasElementsCompatibleWith(p);

-- True iff for all elements X contained by t there exists an element Y contained by self
-- that is compatible with X.
helper context UML2!"uml::TypedElement" def : hasElementsCompatibleWith(t : UML2!"uml::TypedElement") : Boolean =
	self.typedElementHasElementsCompatibleWith(t);
	
-- True iff for all elements X contained by e there exists an element Y contained by self
-- that is compatible with X.
helper context UML2!"uml::NamedElement" def : hasElementsCompatibleWith(e : UML2!"uml::NamedElement") : Boolean =
	self.namedElementHasElementsCompatibleWith(e);

-- Reusable hasElementsCompatibleWith helper for all TypedElements.
helper context UML2!"uml::TypedElement" def : typedElementHasElementsCompatibleWith(t : UML2!"uml::TypedElement") : Boolean =
	self.namedElementHasElementsCompatibleWith(t);

-- Reusable hasElementsCompatibleWith helper for all NamedElements.
helper context UML2!"uml::NamedElement" def : namedElementHasElementsCompatibleWith(e : UML2!"uml::NamedElement") : Boolean =
	let compSuppliers : Sequence(UML2!"uml::NamedElement") = self.allSuppliersIncompatibleWith(e)
	in if compSuppliers->isEmpty() then true else
		compSuppliers.debug(thisModule.modelName.prefix + self.qualifiedName + ' misses dependency suppliers compatible with ')->isEmpty() endif;

-- ------------------------ allOwnedClassifiersLocallyIncompatibleWith --

-- All Classifiers X (transitively) contained by p, for which there exists
-- no Classifier Y (transitively) contained by self that is locally compatible with X,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::Package" def : allOwnedClassifiersLocallyIncompatibleWith(p : UML2!"uml::Package") : Sequence(UML2!"uml::Classifier") =
	p.allOwnedClassifiers->select(c|not self.hasOwnedClassifierLocallyCompatibleWith(c));

-- ------------------------ allOwnedClassifiersIncompatibleWith ---------

-- All Classifiers X (transitively) contained by p, for which there exists
-- no Classifier Y (transitively) contained by self that is compatible with X.
helper context UML2!"uml::Package" def : allOwnedClassifiersIncompatibleWith(p : UML2!"uml::Package") : Sequence(UML2!"uml::Classifier") =
	p.allOwnedClassifiers->select(c|not self.hasOwnedClassifierCompatibleWith(c));

-- ------------------------ hasOwnedClassifierLocallyCompatibleWith -----

-- True iff there exists a Classifier contained by self that is locally compatible with c,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::Package" def : hasOwnedClassifierLocallyCompatibleWith(c : UML2!"uml::Classifier") : Boolean =
	self.allOwnedClassifiers->select(o|o.isLocallyCompatibleWith(c))->notEmpty();

-- ------------------------ hasOwnedClassifierCompatibleWith ------------

-- True iff there exists a Classifier contained by self that is compatible with c.
helper context UML2!"uml::Package" def : hasOwnedClassifierCompatibleWith(c : UML2!"uml::Classifier") : Boolean =
	self.allOwnedClassifiers->select(o|o.isCompatibleWith(c))->notEmpty();

-- ------------------------ allGeneralsIncompatibleWith -----------------

-- All general Classifiers X of c, for which there exists no general Classifier Y of self
-- that is compatible with X.
helper context UML2!"uml::Classifier" def : allGeneralsIncompatibleWith(c : UML2!"uml::Classifier")  : Sequence(UML2!"uml::Classifier") =
	c.general->select(g|not self.hasGeneralCompatibleWith(g));

-- ------------------------ hasGeneralCompatibleWith --------------------

helper context UML2!"uml::Classifier" def : hasGeneralCompatibleWith(c : UML2!"uml::Classifier") : Boolean =
	self.general->select(g|if (g.umlQualifiedName = c.umlQualifiedName) then true else g.hasGeneralCompatibleWith(c) endif)->notEmpty();

-- ------------------------ allFeaturesLocallyIncompatibleWith ----------

-- All Features X of c, for which there exists no Feature Y of self
-- that is locally compatible with X,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::Classifier" def : allFeaturesLocallyIncompatibleWith(c : UML2!"uml::Classifier")  : Sequence(UML2!"uml::Feature") =
	c.allFeatures->select(f|not self.hasFeatureLocallyCompatibleWith(f));

-- ------------------------ allFeaturesIncompatibleWith -----------------

-- All Features X of c, for which there exists no Feature Y of self
-- that is compatible with X.
helper context UML2!"uml::Classifier" def : allFeaturesIncompatibleWith(c : UML2!"uml::Classifier")  : Sequence(UML2!"uml::Feature") =
	c.allFeatures->select(f|not self.hasFeatureCompatibleWith(f));

-- ------------------------ hasFeatureLocallyCompatibleWith -------------

-- True iff self contains a Feature that is locally compatible with f,
-- where locally compatible means compatible without considering any contained elements.
helper context UML2!"uml::Classifier" def : hasFeatureLocallyCompatibleWith(f : UML2!"uml::Feature") : Boolean =
	self.allFeatures->select(o|o.isLocallyCompatibleWith(f))->notEmpty();

-- ------------------------ hasFeatureCompatibleWith --------------------

-- True iff self contains a Feature that is compatible with f.
helper context UML2!"uml::Classifier" def : hasFeatureCompatibleWith(f : UML2!"uml::Feature") : Boolean =
	self.allFeatures->select(o|o.isCompatibleWith(f))->notEmpty();

-- ------------------------ compatibleParameters ------------------------

-- True iff for all O in otherpars, the matching S in selfpars is compatible with O.
helper def : compatibleParameters(selfpars : Sequence(UML2!"uml::Parameter"), otherpars : Sequence(UML2!"uml::Parameter")) : Boolean =
	let selfpar : UML2!"uml::Parameter" = selfpars->first() in
	let otherpar : UML2!"uml::Parameter" = otherpars->first() in
	if selfpar.oclIsUndefined() then otherpar.oclIsUndefined()
	else
		if selfpar.isCompatibleWith(otherpar) then
			thisModule.compatibleParameters(
				selfpars->excluding(selfpar), 
				otherpars->excluding(otherpar))
		else false endif
	endif;

-- ------------------------ visibilityIsCompatibleWith ------------------

-- True iff the visibility of self is compatible with the visibility of e.
helper context UML2!"uml::NamedElement" def : visibilityIsCompatibleWith(e : UML2!"uml::NamedElement") : Boolean =
	if (self.visibility = #public) then true
	else if (self.visibility = #protected) then (e.visibility = #protected) or (e.visibility = #private)
	else if (self.visibility = #package) then (e.visibility = #package) or (e.visibility = #private)
	else (self.visibility = e.visibility) endif endif endif;

-- ------------------------ allSuppliersIncompatibleWith ----------------

-- All suppliers X from e, for which self has no supplier Y that is compatible with X.
helper context UML2!"uml::NamedElement" def : allSuppliersIncompatibleWith(e : UML2!"uml::NamedElement") : Sequence(UML2!"uml::NamedElement") =
	e.suppliers->select(d|not self.hasSupplierCompatibleWith(d));

-- ------------------------ hasSupplierCompatibleWith -------------------

-- True iff self, or one of its generals, has a supplier that is compatible with e.
helper context UML2!"uml::Classifier" def : hasSupplierCompatibleWith(e : UML2!"uml::NamedElement") : Boolean =
	if self.namedElementHasSupplierCompatibleWith(e) then true
	else self.general->select(g|g.hasSupplierCompatibleWith(e))->notEmpty() endif;

-- True iff self has a supplier that is compatible with e.
helper context UML2!"uml::NamedElement" def : hasSupplierCompatibleWith(e : UML2!"uml::NamedElement") : Boolean =
	self.namedElementHasSupplierCompatibleWith(e);

-- Reusable hasSupplierCompatibleWith helper for all NamedElements.
helper context UML2!"uml::NamedElement" def : namedElementHasSupplierCompatibleWith(e : UML2!"uml::NamedElement") : Boolean =
	self.allSuppliers
		->select(s|s.umlQualifiedName = e.umlQualifiedName)->notEmpty();

-- ======================================================================
-- helper methods end
-- ======================================================================
