-- @atlcompiler atl2006
-- @nsURI UML2=http://www.eclipse.org/uml2/3.0.0/UML
-- $Id$
-- Merges two CompatibilityReport UML2 models.
--
-- * Requires the input models to be generated by Jar2UML 
-- * TODO: does not scale sufficiently (2.349,072s for merge of J2SE + J2EE 1.2)
--
module UML2APIMerge; -- extends UML2CopyMerge

create OUT : UML2		-- The merged compatibility report model
from IN : UML2, 		-- The first input API model
     MERGE : UML2; 		-- The second input API model

uses UML2;
uses UML2Comparison;

-- ======================================================================
-- helper attributes begin
-- ======================================================================

-- ------------------------ mergeElements -------------------------------

helper def : mergeElements : Set(UML2!"ecore::EObject") = 
	UML2!"ecore::EObject".allInstancesFrom('MERGE');

-- ======================================================================
-- general context helper attributes begin
-- ======================================================================

-- ------------------------ inIn ----------------------------------------

helper context UML2!"uml::NamedElement" def : inIn : Sequence(UML2!"uml::NamedElement") =
	self.owner.inIn->collect(c|c.ownedElement)->flatten()->select(n|self.sameAs(n)).debug('inIn');

helper context UML2!"uml::Feature" def : inIn : Sequence(UML2!"uml::Feature") =
	self.featuringClassifier.inIn->collect(c|c.feature)->flatten()->select(n|self.sameAs(n));
--	self.owner.inIn->collect(c|c.ownedElement)->flatten()->select(n|self.sameAs(n));

helper context UML2!"uml::Parameter" def : inIn : Sequence(UML2!"uml::Parameter") =
	self.owner.inIn->collect(o|o.ownedParameter)->flatten()->select(n|self.sameAs(n));

--helper context UML2!"uml::Classifier" def : inIn : Sequence(UML2!"uml::Classifier") =
--	UML2!"uml::Classifier".allInstancesFrom('IN')->select(n|self.sameAs(n));

helper context UML2!"uml::Package" def : inIn : Sequence(UML2!"uml::Package") =
	UML2!"uml::Package".allInstancesFrom('IN')->select(n|self.sameAs(n)).debug('inIn');

helper context OclAny def : inIn : Sequence(OclAny) = Sequence{};

-- ------------------------ inMerge -------------------------------------

helper context UML2!"uml::NamedElement" def : inMerge : Sequence(UML2!"uml::NamedElement") =
	self.owner.inMerge->collect(c|c.ownedElement)->flatten()->select(n|self.sameAs(n)).debug('inMerge');

helper context UML2!"uml::Feature" def : inMerge : Sequence(UML2!"uml::Feature") =
	self.featuringClassifier.inMerge->collect(c|c.feature)->flatten()->select(n|self.sameAs(n));
--	self.owner.inMerge->collect(c|c.ownedElement)->flatten()->select(n|self.sameAs(n));

helper context UML2!"uml::Parameter" def : inMerge : Sequence(UML2!"uml::Parameter") =
	self.owner.inMerge->collect(o|o.ownedParameter)->flatten()->select(n|self.sameAs(n));

--helper context UML2!"uml::Classifier" def : inMerge : Sequence(UML2!"uml::Classifier") =
--	UML2!"uml::Classifier".allInstancesFrom('MERGE')->select(n|self.sameAs(n));

helper context UML2!"uml::Package" def : inMerge : Sequence(UML2!"uml::Package") =
	UML2!"uml::Package".allInstancesFrom('MERGE')->select(n|self.sameAs(n)).debug('inMerge');

helper context OclAny def : inMerge : Sequence(OclAny) = Sequence{};

-- ------------------------ mergedName ----------------------------------

helper context UML2!"uml::Model" def : mergedName : String =
	UML2!"uml::Model".allInstancesFrom('MERGE')->iterate(e; acc : String = self.name |
		e.name + ' + ' + acc).debug('mergedName');

-- ------------------------ isInElement ---------------------------------

helper context OclAny def : isInElement : Boolean =
	self.inMerge->isEmpty() or self.inIn->isEmpty();
--	thisModule.copyElements->includes(self);
	
-- ------------------------ copyElements --------------------------------

--helper def : copyElements : Set(UML2!"ecore::EObject") =
--	UML2!"ecore::EObject".allInstancesFrom('IN')
--		->select(e|e.inMerge->isEmpty())
--		->union(
--	UML2!"ecore::EObject".allInstancesFrom('MERGE')
--		->select(e|e.inIn->isEmpty()));

-- ======================================================================
-- helper attributes end
-- ======================================================================

-- ======================================================================
-- helper methods begin
-- ======================================================================

-- ------------------------ sameAs --------------------------------------

helper context UML2!"uml::Operation" def : sameAs(f : UML2!"uml::Operation") : Boolean =
	if self.namedElementSameAs(f) then
		if (self.ownedParameter->size() = f.ownedParameter->size())
		then thisModule.sameParameters(self.ownedParameter, f.ownedParameter)
		else false endif
	else false endif;

helper context UML2!"uml::Property" def : sameAs(t : UML2!"uml::TypedElement") : Boolean =
	self.typedElementSameAs(t);

helper context UML2!"uml::Parameter" def : sameAs(t : UML2!"uml::TypedElement") : Boolean =
	self.typedElementSameAs(t);

helper context UML2!"uml::NamedElement" def : sameAs(n : UML2!"uml::NamedElement") : Boolean =
	self.namedElementSameAs(n);

helper context UML2!"ecore::EObject" def : sameAs(o : UML2!"ecore::EObject") : Boolean =
	false;

helper context UML2!"uml::TypedElement" def : typedElementSameAs(t : UML2!"uml::TypedElement") : Boolean =
	if self.namedElementSameAs(t)
	then if self.type.oclIsUndefined()
		 then t.type.oclIsUndefined()
		 else if t.type.oclIsUndefined()
		 	  then false
			  else (self.type.umlQualifiedName = t.type.umlQualifiedName)
			  endif
		 endif
	else false endif;

helper context UML2!"uml::NamedElement" def : namedElementSameAs(n : UML2!"uml::NamedElement") : Boolean =
	n.umlQualifiedName = self.umlQualifiedName and
	n.oclType() = self.oclType();

-- ------------------------ sameParameters ------------------------------

helper def : sameParameters(selfpars : Sequence(UML2!"uml::Parameter"), otherpars : Sequence(UML2!"uml::Parameter")) : Boolean =
	let selfpar : UML2!"uml::Parameter" = selfpars->first() in
	let otherpar : UML2!"uml::Parameter" = otherpars->first() in
	if selfpar.oclIsUndefined() then otherpar.oclIsUndefined()
	else
		if selfpar.sameAs(otherpar) then
			thisModule.sameParameters(
				selfpars->excluding(selfpar), 
				otherpars->excluding(otherpar))
		else false endif
	endif;

-- ------------------------ mergedEAnnotations --------------------------

helper context UML2!"ecore::EModelElement" def : mergedEAnnotations(m : UML2!"ecore::EModelElement") : Sequence(UML2!"ecore::EAnnotation") =
	let oneInferred : Boolean = self.isInferred xor m.isInferred in
	if oneInferred then
		self.eAnnotations->union(m.eAnnotations)
		->reject(a|a.source = 'Jar2UML' and a.details
			->exists(d|d.key = 'inferred' and d.value = 'true'))
	else -- both or none inferred
		self.eAnnotations->union(m.eAnnotations)
	endif;

-- ======================================================================
-- helper methods end
-- ======================================================================

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule Model {
    from s : UML2!"uml::Model",
         m : UML2!"uml::Model" (
		if thisModule.inElements->includes(s) then
			thisModule.mergeElements->includes(m)
		else false endif)
	to t : UML2!"uml::Model" (
        name <- s.mergedName.debug('Model'),
        visibility <- s.visibility,
        eAnnotations <- s.mergedEAnnotations(m),
        ownedComment <- s.ownedComment->union(m.ownedComment),
        clientDependency <- s.clientDependency->union(m.clientDependency),
        elementImport <- s.elementImport->union(m.elementImport),
        packageImport <- s.packageImport->union(m.packageImport),
        ownedRule <- s.ownedRule->union(m.ownedRule),
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding->union(m.templateBinding),
        ownedTemplateSignature <- s.ownedTemplateSignature,
        packageMerge <- s.packageMerge->union(m.packageMerge),
        packagedElement <- s.packagedElement->union(m.packagedElement),
        profileApplication <- s.profileApplication->union(m.profileApplication))
}

rule MergePackage {
    from s : UML2!"uml::Package",
	     m : UML2!"uml::Package" (
		if s.oclIsTypeOf(UML2!"uml::Package") then
			if thisModule.inElements->includes(s) then
				s.inMerge->includes(m)
			else false endif
		else false endif)
    to t : UML2!"uml::Package" (
        name <- s.name.debug('MergePackage'),
        visibility <- s.visibility,
        eAnnotations <- s.mergedEAnnotations(m),
        ownedComment <- s.ownedComment->union(m.ownedComment),
        clientDependency <- s.clientDependency->union(m.clientDependency),
        elementImport <- s.elementImport->union(m.elementImport),
        packageImport <- s.packageImport->union(m.packageImport),
        ownedRule <- s.ownedRule->union(m.ownedRule),
        templateParameter <- s.templateParameter, -- just copy
        templateBinding <- s.templateBinding->union(m.templateBinding),
        ownedTemplateSignature <- s.ownedTemplateSignature, -- just copy
        packageMerge <- s.packageMerge->union(m.packageMerge),
        packagedElement <- s.packagedElement->union(m.packagedElement),
        profileApplication <- s.profileApplication->union(m.profileApplication))
}

rule MergeClass {
    from s : UML2!"uml::Class",
		 m : UML2!"uml::Class" (
		if s.oclIsTypeOf(UML2!"uml::Class") then
			if thisModule.inElements->includes(s) then
				s.inMerge->includes(m)
			else false endif
		else false endif)
    to t : UML2!"uml::Class" (
        name <- s.name.debug('MergeClass'),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        eAnnotations <- s.mergedEAnnotations(m),
        ownedComment <- s.ownedComment->union(m.ownedComment),
        clientDependency <- s.clientDependency->union(m.clientDependency),
        elementImport <- s.elementImport->union(m.elementImport),
        packageImport <- s.packageImport->union(m.packageImport),
        ownedRule <- s.ownedRule->union(m.ownedRule),
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding->union(m.templateBinding),
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization->union(m.generalization),
        powertypeExtent <- s.powertypeExtent->union(m.powertypeExtent),
        redefinedClassifier <- s.redefinedClassifier->union(m.redefinedClassifier),
        substitution <- s.substitution->union(m.substitution),
        representation <- s.representation,
        collaborationUse <- s.collaborationUse->union(m.collaborationUse),
        ownedUseCase <- s.ownedUseCase->union(m.ownedUseCase),
        useCase <- s.useCase->union(m.useCase),
        ownedAttribute <- s.ownedAttribute->union(m.ownedAttribute),
        ownedConnector <- s.ownedConnector->union(m.ownedConnector),
        ownedBehavior <- s.ownedBehavior->union(m.ownedBehavior),
        classifierBehavior <- s.classifierBehavior->union(m.classifierBehavior),
        interfaceRealization <- s.interfaceRealization->union(m.interfaceRealization),
        ownedTrigger <- s.ownedTrigger->union(m.ownedTrigger),
        nestedClassifier <- s.nestedClassifier->union(m.nestedClassifier),
        ownedOperation <- s.ownedOperation->union(m.ownedOperation),
        ownedReception <- s.ownedReception->union(m.ownedReception))
}

rule MergeDataType {
    from s : UML2!"uml::DataType",
	     m : UML2!"uml::DataType" (
		if s.oclIsTypeOf(UML2!"uml::DataType") then
			if thisModule.inElements->includes(s) then
				s.inMerge->includes(m)
			else false endif
		else false endif)
    to t : UML2!"uml::DataType" (
        name <- s.name.debug('MergeDataType'),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.mergedEAnnotations(m),
        ownedComment <- s.ownedComment->union(m.ownedComment),
        clientDependency <- s.clientDependency->union(m.clientDependency),
        elementImport <- s.elementImport->union(m.elementImport),
        packageImport <- s.packageImport->union(m.packageImport),
        ownedRule <- s.ownedRule->union(m.ownedRule),
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding->union(m.templateBinding),
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization->union(m.generalization),
        powertypeExtent <- s.powertypeExtent->union(m.powertypeExtent),
        redefinedClassifier <- s.redefinedClassifier->union(m.redefinedClassifier),
        substitution <- s.substitution->union(m.substitution),
        representation <- s.representation,
        collaborationUse <- s.collaborationUse->union(m.collaborationUse),
        ownedUseCase <- s.ownedUseCase->union(m.ownedUseCase),
        useCase <- s.useCase->union(m.useCase),
        ownedAttribute <- s.ownedAttribute->union(m.ownedAttribute),
        ownedOperation <- s.ownedOperation->union(m.ownedOperation))
}

rule MergeInterface {
    from s : UML2!"uml::Interface",
	     m : UML2!"uml::Interface" (
    	if thisModule.inElements->includes(s) then
			s.inMerge->includes(m)
		else false endif)
    to t : UML2!"uml::Interface" (
        name <- s.name.debug('MergeInterface'),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.mergedEAnnotations(m),
        ownedComment <- s.ownedComment->union(m.ownedComment),
        clientDependency <- s.clientDependency->union(m.clientDependency),
        elementImport <- s.elementImport->union(m.elementImport),
        packageImport <- s.packageImport->union(m.packageImport),
        ownedRule <- s.ownedRule->union(m.ownedRule),
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding->union(m.templateBinding),
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization->union(m.generalization),
        powertypeExtent <- s.powertypeExtent->union(m.powertypeExtent),
        redefinedClassifier <- s.redefinedClassifier->union(m.redefinedClassifier),
        substitution <- s.substitution->union(m.substitution),
        representation <- s.representation,
        collaborationUse <- s.collaborationUse->union(m.collaborationUse),
        ownedUseCase <- s.ownedUseCase->union(m.ownedUseCase),
        useCase <- s.useCase->union(m.useCase),
        ownedAttribute <- s.ownedAttribute->union(m.ownedAttribute),
        ownedOperation <- s.ownedOperation->union(m.ownedOperation),
        nestedClassifier <- s.nestedClassifier->union(m.nestedClassifier),
        redefinedInterface <- s.redefinedInterface->union(m.r),
        ownedReception <- s.ownedReception->union(m.ownedReception),
        protocol <- s.protocol)
}

rule MergeOperation {
    from s : UML2!"uml::Operation",
	     m : UML2!"uml::Operation" (
    	if thisModule.inElements->includes(s) then
			s.inMerge->includes(m)
		else false endif)
    to t : UML2!"uml::Operation" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isAbstract <- s.isAbstract,
        concurrency <- s.concurrency,
        isQuery <- s.isQuery,
        eAnnotations <- s.mergedEAnnotations(m),
        ownedComment <- s.ownedComment->union(m.ownedComment),
        clientDependency <- s.clientDependency->union(m.clientDependency),
        elementImport <- s.elementImport->union(m.elementImport),
        packageImport <- s.packageImport->union(m.packageImport),
        ownedRule <- s.ownedRule->union(m.ownedRule),
        ownedParameter <- s.ownedParameter, -- same; don't merge
        method <- s.method,
        raisedException <- s.raisedException,
        ownedParameterSet <- s.ownedParameterSet,
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding,
        ownedTemplateSignature <- s.ownedTemplateSignature,
        precondition <- s.precondition,
        postcondition <- s.postcondition,
        redefinedOperation <- s.redefinedOperation,
        bodyCondition <- s.bodyCondition)
}

rule MergeParameter {
    from s : UML2!"uml::Parameter",
	     m : UML2!"uml::Parameter" (
	     	if thisModule.inElements->includes(s) then
				s.inMerge->includes(m.inMerge)
			else false endif)
    to t : UML2!"uml::Parameter" (
        name <- s.name,
        visibility <- s.visibility,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        direction <- s.direction,
        isException <- s.isException,
        isStream <- s.isStream,
        effect <- s.effect,
        eAnnotations <- s.mergedEAnnotations(m),
        ownedComment <- s.ownedComment->union(m.ownedComment),
        clientDependency <- s.clientDependency->union(m.clientDependency),
        type <- s.type,
        templateParameter <- s.templateParameter,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        parameterSet <- s.parameterSet,
        defaultValue <- s.defaultValue)
}

rule MergePrimitiveType {
    from s : UML2!"uml::PrimitiveType",
	     m : UML2!"uml::PrimitiveType" (
	     	if thisModule.inElements->includes(s) then
				s.inMerge->includes(m)
			else false endif)
    to t : UML2!"uml::PrimitiveType" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        eAnnotations <- s.mergedEAnnotations(m),
        ownedComment <- s.ownedComment->union(m.ownedComment),
        clientDependency <- s.clientDependency->union(m.clientDependency),
        elementImport <- s.elementImport->union(m.elementImport),
        packageImport <- s.packageImport->union(m.packageImport),
        ownedRule <- s.ownedRule->union(m.ownedRule),
        templateParameter <- s.templateParameter,
        templateBinding <- s.templateBinding->union(m.templateBinding),
        ownedTemplateSignature <- s.ownedTemplateSignature,
        generalization <- s.generalization->union(m.generalization),
        powertypeExtent <- s.powertypeExtent->union(m.powertypeExtent),
        redefinedClassifier <- s.redefinedClassifier->union(m.redefinedClassifier),
        substitution <- s.substitution->union(m.substitution),
        representation <- s.representation,
        collaborationUse <- s.collaborationUse->union(m.collaborationUse),
        ownedUseCase <- s.ownedUseCase->union(m.ownedUseCase),
        useCase <- s.useCase->union(m.useCase),
        ownedAttribute <- s.ownedAttribute->union(m.ownedAttribute),
        ownedOperation <- s.ownedOperation->union(m.ownedOperation))
}

rule MergeProperty {
    from s : UML2!"uml::Property",
	     m : UML2!"uml::Property" (
		if s.oclIsTypeOf(UML2!"uml::Property") then
			if thisModule.inElements->includes(s) then
				s.inMerge->includes(m)
			else false endif
		else false endif)
    to t : UML2!"uml::Property" (
        name <- s.name,
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        isDerived <- s.isDerived,
        isDerivedUnion <- s.isDerivedUnion,
        aggregation <- s.aggregation,
        eAnnotations <- s.mergedEAnnotations(m),
        ownedComment <- s.ownedComment->union(m.ownedComment),
        clientDependency <- s.clientDependency->union(m.clientDependency),
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue,
        templateParameter <- s.templateParameter,
        deployment <- s.deployment->union(m.deployment),
        redefinedProperty <- s.redefinedProperty->union(m.redefinedElement),
        defaultValue <- s.defaultValue,
        subsettedProperty <- s.subsettedProperty->union(m.subsettedProperty),
        association <- s.association,
        qualifier <- s.qualifier)
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
