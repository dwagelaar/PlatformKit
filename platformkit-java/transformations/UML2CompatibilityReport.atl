-- @atlcompiler atl2006
-- @nsURI UML2=http://www.eclipse.org/uml2/3.0.0/UML
-- $Id$
-- Creates a report of the compatibility of a UML2 model
-- with a reference version of the UML2 model.
module UML2CompatibilityReport;

create REPORT : UML2	-- The compatibility report model, containing any missing elements
from IN : UML2, 		-- The reference model to compare against the dependencies model
     DEPS : UML2, 		-- The dependencies model that should be satisfied by the reference model
	 CR : UML2;			-- The CompatibilityReport profile

uses UML2;
uses UML2Comparison;

-- ======================================================================
-- helper attributes begin
-- ======================================================================

helper def : UML2CompatibilityReportVersionString : String =
	'$Id$';

helper def : inElements : Set(UML2!"ecore::EObject") =
	UML2!"ecore::EObject".allInstancesFrom('IN');

helper def : depsElements : Set(UML2!"ecore::EObject") =
	UML2!"ecore::EObject".allInstancesFrom('DEPS');

helper def : crProfile : UML2!"uml::Profile" = 
	'CompatibilityReport'.profile();

helper def : stCompatibilityReport : UML2!"uml::Stereotype" =
	'CompatibilityReport'.stereotype();

helper def : stIncompatible : UML2!"uml::Stereotype" =
	'Incompatible'.stereotype();

helper def : stMissing : UML2!"uml::Stereotype" =
	'Missing'.stereotype();

helper def : crPackages : Sequence(UML2!"ecore::EPackage") =
	UML2!"ecore::EPackage".allInstancesFrom('CR')->select(p|p.name='CompatibilityReport');

helper context UML2!"uml::Model" def : locallyIncompPacks : Sequence(UML2!"uml::Package") = 
	UML2!"uml::Model".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->collect(m|m.allPackagesLocallyIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::Model" def : incompPacks : Sequence(UML2!"uml::Package") = 
	UML2!"uml::Model".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->collect(m|m.allPackagesIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::Package" def : locallyIncompClasses : Sequence(UML2!"uml::Classifier") = 
	UML2!"uml::Package".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->select(e|e.umlQualifiedName=self.umlQualifiedName)
		->collect(p|p.allOwnedClassifiersLocallyIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::Package" def : incompClasses : Sequence(UML2!"uml::Classifier") = 
	UML2!"uml::Package".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->select(e|e.umlQualifiedName=self.umlQualifiedName)
		->collect(p|p.allOwnedClassifiersIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::Classifier" def : incompGenerals : Sequence(UML2!"uml::Classifier") = 
	UML2!"uml::Classifier".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->select(e|e.umlQualifiedName=self.umlQualifiedName)
		->collect(p|p.allGeneralsIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::Classifier" def : incompFeatures : Sequence(UML2!"uml::Feature") = 
	UML2!"uml::Classifier".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->select(e|e.umlQualifiedName=self.umlQualifiedName)
		->collect(p|p.allFeaturesIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::NamedElement" def : incompSuppliers : Sequence(UML2!"uml::NamedElement") = 
	UML2!"uml::NamedElement".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->select(e|e.umlQualifiedName=self.umlQualifiedName)
		->collect(p|p.allSuppliersIncompatibleWith(self))
		->flatten();

helper context UML2!"ecore::EObject" def : isMissing : Boolean =
	false;

helper context UML2!"ecore::EStringToStringMapEntry" def : isMissing : Boolean =
	false;

helper context UML2!"uml::Package" def : isMissing : Boolean =
	if self.hasMissingOwner then true else
		self.getModel().locallyIncompPacks->includes(self)
	endif;

helper context UML2!"uml::Class" def : isMissing : Boolean =
	if self.hasMissingOwner then true else
		self.getNearestPackage().locallyIncompClasses->includes(self)
	endif;

helper context UML2!"uml::Interface" def : isMissing : Boolean =
	if self.hasMissingOwner then true else
		self.getNearestPackage().locallyIncompClasses->includes(self)
	endif;

helper context UML2!"uml::Generalization" def : isMissing : Boolean =
	if self.specific.isMissing then true else
		self.specific.incompGenerals->includes(self.general)
	endif;

helper context UML2!"uml::InterfaceRealization" def : isMissing : Boolean =
	if self.implementingClassifier.isMissing then true else
		self.implementingClassifier.incompSuppliers->exists(i|self.supplier->includes(i))
	endif;

helper context UML2!"uml::Property" def : isMissing : Boolean =
	if self.hasMissingOwner then true else
		if self.class.oclIsUndefined() then false else
			self.class.incompFeatures->includes(self)
		endif
	endif;

helper context UML2!"uml::Operation" def : isMissing : Boolean =
	if self.hasMissingOwner then true else
		if self.class.oclIsUndefined() then
			if self.interface.oclIsUndefined() then false else
				self.interface.incompFeatures->includes(self)
			endif
		else
			self.class.incompFeatures->includes(self)
		endif
	endif;

helper context UML2!"uml::Parameter" def : isMissing : Boolean =
	if self.operation.oclIsUndefined() then false else
		self.operation.isMissing
	endif;

helper context UML2!"uml::LiteralUnlimitedNatural" def : isMissing : Boolean =
	self.refImmediateComposite().isMissing;

helper context UML2!"uml::LiteralInteger" def : isMissing : Boolean =
	self.refImmediateComposite().isMissing;

helper context UML2!"uml::Element" def : hasElementsMissing : Boolean =
	false;

helper context UML2!"uml::Package" def : hasElementsMissing : Boolean =
	if self.hasMissingOwner then false else
		(self.getModel().incompPacks->includes(self) or
	 	self.getModel().incompPacks->exists(p|self.allOwnedPackages->includes(p)))
	endif;

helper context UML2!"uml::Class" def : hasElementsMissing : Boolean =
	if self.hasMissingOwner then false else
		let pack : UML2!"uml::Package" = self.getNearestPackage() in
		(pack.incompClasses->includes(self) or
	 	pack.incompClasses->exists(c|self.allOwnedClassifiers->includes(c)))
	endif;

helper context UML2!"uml::Interface" def : hasElementsMissing : Boolean =
	if self.hasMissingOwner then false else
		let pack : UML2!"uml::Package" = self.getNearestPackage() in
		(pack.incompClasses->includes(self) or
	 	pack.incompClasses->exists(c|self.allOwnedClassifiers->includes(c)))
	endif;

helper context UML2!"uml::Element" def : hasMissingOwner : Boolean =
	if self.owner.oclIsUndefined() then false else
		if self.owner.isMissing then true else
			self.owner.hasMissingOwner
		endif
	endif;

-- ======================================================================
-- helper attributes end
-- ======================================================================

-- ======================================================================
-- helper methods begin
-- ======================================================================

helper context OclAny def : join(separator : String) : String =
	if self.oclIsKindOf(Sequence(OclAny)) then
		self->iterate(e; acc : String = '' |
			if acc = '' then acc + e.toString()
			else acc + separator + e endif)
	else '' endif;

-- ======================================================================
-- helper methods end
-- ======================================================================

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule Model {
	from s : UML2!"uml::Model" (
		thisModule.depsElements->includes(s))
	using {
		provides : String = UML2!"uml::Model".allInstancesFrom('IN')
			->collect(m|m.name)
			->join(', ');
	}
    to t : UML2!"uml::Model" (
        name <- (provides + ' provides ' + s.name.toString()).debug('Creating compatibility report'),
		eAnnotations <- s.eAnnotations,
        packagedElement <- s.packagedElement),
	   a : UML2!"ecore::EAnnotation" (
	   	eModelElement <- s,
		source <- 'PlatformKit',
		details <- Sequence{vi}),
	   vi : UML2!"ecore::EStringToStringMapEntry" (
	   	key <- 'versionInfo',
		value <- thisModule.UML2CompatibilityReportVersionString)
	do {
		t.applyProfile(thisModule.crProfile);
		t.applyStereotype(thisModule.stCompatibilityReport);
	}
}

rule EAnnotation {
    from s : UML2!"ecore::EAnnotation" (
    	thisModule.depsElements->includes(s))
    to t : UML2!"ecore::EAnnotation" (
        source <- s.source,
        eAnnotations <- s.eAnnotations,
        details <- s.details,
        contents <- s.contents,
        references <- s.references)
}

rule EStringToStringMapEntry {
    from s : UML2!"ecore::EStringToStringMapEntry" (
    	thisModule.depsElements->includes(s))
    to t : UML2!"ecore::EStringToStringMapEntry" (
        key <- s.key,
        value <- s.value)
}

rule Package {
	from s : UML2!"uml::Package" (
		if thisModule.depsElements->includes(s) then
			if s.oclIsTypeOf(UML2!"uml::Package") then
				if s.isMissing then false else
					not s.hasElementsMissing
				endif
			else false endif
		else false endif)
    to t : UML2!"uml::Package" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        packagedElement <- s.packagedElement)
}

rule IncompatiblePackage {
	from s : UML2!"uml::Package" (
		if thisModule.depsElements->includes(s) then
			if s.oclIsTypeOf(UML2!"uml::Package") then
				if s.isMissing then false else
					s.hasElementsMissing
				endif
			else false endif
		else false endif)
    to t : UML2!"uml::Package" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        packagedElement <- s.packagedElement)
	do {
		t.applyStereotype(thisModule.stIncompatible);
	}
}

rule MissingPackage {
	from s : UML2!"uml::Package" (
		if thisModule.depsElements->includes(s) then
			if s.oclIsTypeOf(UML2!"uml::Package") then
				s.isMissing
			else false endif
		else false endif)
    to t : UML2!"uml::Package" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        packagedElement <- s.packagedElement)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule Class {
    from s : UML2!"uml::Class" (
		if thisModule.depsElements->includes(s) then
    		if s.oclIsTypeOf(UML2!"uml::Class") then
				if s.isMissing then false else
					not s.hasElementsMissing
				endif
			else false endif
		else false endif)
    to t : UML2!"uml::Class" (
        name <- s.name.debug('>>Class<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        generalization <- s.generalization,
		ownedAttribute <- s.ownedAttribute,
        interfaceRealization <- s.interfaceRealization,
		nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation)
}

rule IncompatibleClass {
    from s : UML2!"uml::Class" (
		if thisModule.depsElements->includes(s) then
    		if s.oclIsTypeOf(UML2!"uml::Class") then
				if s.isMissing then false else
					s.hasElementsMissing
				endif
			else false endif
		else false endif)
    to t : UML2!"uml::Class" (
        name <- s.name.debug('>>IncompatibleClass<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        generalization <- s.generalization,
		ownedAttribute <- s.ownedAttribute,
        interfaceRealization <- s.interfaceRealization,
		nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation)
	do {
		t.applyStereotype(thisModule.stIncompatible);
	}
}

rule MissingClass {
    from s : UML2!"uml::Class" (
		if thisModule.depsElements->includes(s) then
    		if s.oclIsTypeOf(UML2!"uml::Class") then
				s.isMissing
			else false endif
		else false endif)
    to t : UML2!"uml::Class" (
        name <- s.name.debug('>>MissingClass<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        generalization <- s.generalization,
		ownedAttribute <- s.ownedAttribute,
        interfaceRealization <- s.interfaceRealization,
		nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule Interface {
    from s : UML2!"uml::Interface" (
		if thisModule.depsElements->includes(s) then
    		if s.isMissing then false else
    			not s.hasElementsMissing
			endif
		else false endif)
	to t : UML2!"uml::Interface" (
        name <- s.name.debug('>>Interface<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization,
        ownedAttribute <- s.ownedAttribute,
		ownedOperation <- s.ownedOperation,
        nestedClassifier <- s.nestedClassifier)
}

rule IncompatibleInterface {
    from s : UML2!"uml::Interface" (
		if thisModule.depsElements->includes(s) then
    		if s.isMissing then false else
    			s.hasElementsMissing
			endif
		else false endif)
	to t : UML2!"uml::Interface" (
        name <- s.name.debug('>>IncompatibleInterface<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization,
        ownedAttribute <- s.ownedAttribute,
		ownedOperation <- s.ownedOperation,
        nestedClassifier <- s.nestedClassifier)
	do {
		t.applyStereotype(thisModule.stIncompatible);
	}
}

rule MissingInterface {
    from s : UML2!"uml::Interface" (
    	if thisModule.depsElements->includes(s) then
    		s.isMissing
		else false endif)
	to t : UML2!"uml::Interface" (
        name <- s.name.debug('>>MissingInterface<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization,
        ownedAttribute <- s.ownedAttribute,
		ownedOperation <- s.ownedOperation,
        nestedClassifier <- s.nestedClassifier)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule DataType {
    from s : UML2!"uml::DataType" (
		if thisModule.depsElements->includes(s) then
    		if s.oclIsTypeOf(UML2!"uml::DataType") then
		   		not s.isMissing
			else false endif
		else false endif)
	to t : UML2!"uml::DataType" (
        name <- s.name.debug('>>DataType<< ' + s.qualifiedName),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation,
		generalization <- s.generalization)
}

rule MissingDataType {
    from s : UML2!"uml::DataType" (
		if thisModule.depsElements->includes(s) then
    		if s.oclIsTypeOf(UML2!"uml::DataType") then
    			s.isMissing
			else false endif
		else false endif)
	to t : UML2!"uml::DataType" (
        name <- s.name.debug('>>MissingDataType<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        ownedAttribute <- s.ownedAttribute,
        ownedOperation <- s.ownedOperation,
		generalization <- s.generalization)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule PrimitiveType {
    from s : UML2!"uml::PrimitiveType" (
		if thisModule.depsElements->includes(s) then
    		not s.isMissing
		else false endif)
	to t : UML2!"uml::PrimitiveType" (
        name <- s.name.debug('>>PrimitiveType<< ' + s.qualifiedName),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization)
}

rule MissingPrimitiveType {
    from s : UML2!"uml::PrimitiveType" (
		if thisModule.depsElements->includes(s) then
    		s.isMissing
		else false endif)
	to t : UML2!"uml::PrimitiveType" (
        name <- s.name.debug('>>MissingPrimitiveType<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule Generalization {
    from s : UML2!"uml::Generalization" (
		if thisModule.depsElements->includes(s) then
    		not s.isMissing
		else false endif)
    to t : UML2!"uml::Generalization" (
		eAnnotations <- s.eAnnotations,
    	general <- s.general)
}

rule MissingGeneralization {
    from s : UML2!"uml::Generalization" (
		if thisModule.depsElements->includes(s) then
    		s.isMissing
		else false endif)
    to t : UML2!"uml::Generalization" (
		eAnnotations <- s.eAnnotations,
    	general <- s.general)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule InterfaceRealization {
    from s : UML2!"uml::InterfaceRealization" (
		if thisModule.depsElements->includes(s) then
    		not s.isMissing
		else false endif)
    to t : UML2!"uml::InterfaceRealization" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
		supplier <- s.supplier,
        client <- s.client,
        contract <- s.contract)
}

rule MissingInterfaceRealization {
    from s : UML2!"uml::InterfaceRealization" (
		if thisModule.depsElements->includes(s) then
    		s.isMissing
		else false endif)
    to t : UML2!"uml::InterfaceRealization" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
		supplier <- s.supplier,
        client <- s.client,
        contract <- s.contract)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule Property {
    from s : UML2!"uml::Property" (
		if thisModule.depsElements->includes(s) then
    		if s.oclIsTypeOf(UML2!"uml::Property") then
				not s.isMissing
			else false endif
		else false endif)
    to t : UML2!"uml::Property" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

rule MissingProperty {
    from s : UML2!"uml::Property" (
		if thisModule.depsElements->includes(s) then
    		if s.oclIsTypeOf(UML2!"uml::Property") then
				s.isMissing
			else false endif
		else false endif)
    to t : UML2!"uml::Property" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule LiteralUnlimitedNatural {
    from s : UML2!"uml::LiteralUnlimitedNatural" (
    	if thisModule.depsElements->includes(self) then
			let p : UML2!"ecore::EObject" =  s.refImmediateComposite() in
			if p.oclIsTypeOf(UML2!"uml::Property") then true
			else p.oclIsKindOf(UML2!"uml::Parameter") endif
		else false endif)
    to t : UML2!"uml::LiteralUnlimitedNatural" (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value)
}

rule LiteralInteger {
    from s : UML2!"uml::LiteralInteger" (
    	if thisModule.depsElements->includes(self) then
			let p : UML2!"ecore::EObject" =  s.refImmediateComposite() in
			if p.oclIsTypeOf(UML2!"uml::Property") then true
			else p.oclIsKindOf(UML2!"uml::Parameter") endif
		else false endif)
    to t : UML2!"uml::LiteralInteger" (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value)
}

rule Operation {
    from s : UML2!"uml::Operation" (
		if thisModule.depsElements->includes(s) then
    		not s.isMissing
		else false endif)
    to t : UML2!"uml::Operation" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isAbstract <- s.isAbstract,
        concurrency <- s.concurrency,
        isQuery <- s.isQuery,
        ownedParameter <- s.ownedParameter,
        raisedException <- s.raisedException)
}

rule MissingOperation {
    from s : UML2!"uml::Operation" (
		if thisModule.depsElements->includes(s) then
    		s.isMissing
		else false endif)
    to t : UML2!"uml::Operation" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isAbstract <- s.isAbstract,
        concurrency <- s.concurrency,
        isQuery <- s.isQuery,
        ownedParameter <- s.ownedParameter,
        raisedException <- s.raisedException)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule Parameter {
    from s : UML2!"uml::Parameter" (
    	thisModule.depsElements->includes(s))
    to t : UML2!"uml::Parameter" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        direction <- s.direction,
        isException <- s.isException,
        isStream <- s.isStream,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

endpoint rule UML2CompatibilityComparison() {
	do {
		UML2!"uml::Model".allInstancesFrom('IN')
			->collect(m|m.compatibleInPrev)->flatten()->notEmpty()
			.debug('Model is compatible with previous model');
	}
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
