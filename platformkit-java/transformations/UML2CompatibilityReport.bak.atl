-- @atlcompiler atl2006
-- $Id$
-- Creates a report of the compatibility of a UML2 model
-- with a reference version of the UML2 model.
module UML2CompatibilityReport;

create REPORT : UML2	-- The compatibility report model, containing any missing elements
from IN : UML2, 		-- The reference model to compare against the dependencies model
     DEPS : UML2, 		-- The dependencies model that should be satisfied by the reference model
	 CR : UML2;			-- The CompatibilityReport profile

uses UML2;
uses UML2Comparison;

-- ======================================================================
-- helper attributes begin
-- ======================================================================

helper def : UML2CompatibilityReportVersionString : String =
	'$Id: UML2CompatibilityReport.atl 7786 2009-08-18 07:24:48Z dwagelaa $';

helper def : inElements : Set(UML2!"ecore::EObject") =
	UML2!"ecore::EObject".allInstancesFrom('IN');

helper def : depsElements : Set(UML2!"ecore::EObject") =
	UML2!"ecore::EObject".allInstancesFrom('DEPS');

helper def : crProfile : UML2!"uml::Profile" = 
	'CompatibilityReport'.profile();

helper def : stCompatibilityReport : UML2!"uml::Stereotype" =
	'CompatibilityReport'.stereotype();

helper def : stIncompatible : UML2!"uml::Stereotype" =
	'Incompatible'.stereotype();

helper def : stMissing : UML2!"uml::Stereotype" =
	'Missing'.stereotype();

helper def : crPackages : Sequence(UML2!"ecore::EPackage") =
	UML2!"ecore::EPackage".allInstancesFrom('CR')->select(p|p.name='CompatibilityReport');

helper context UML2!"uml::Model" def : locallyIncompPacks : Sequence(UML2!"uml::Package") = 
	UML2!"uml::Model".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->collect(m|m.allPackagesLocallyIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::Model" def : incompPacks : Sequence(UML2!"uml::Package") = 
	UML2!"uml::Model".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->collect(m|m.allPackagesIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::Package" def : locallyIncompClasses : Sequence(UML2!"uml::Classifier") = 
	UML2!"uml::Package".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->select(e|e.umlQualifiedName=self.umlQualifiedName)
		->collect(p|p.allOwnedClassifiersLocallyIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::Package" def : incompClasses : Sequence(UML2!"uml::Classifier") = 
	UML2!"uml::Package".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->select(e|e.umlQualifiedName=self.umlQualifiedName)
		->collect(p|p.allOwnedClassifiersIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::Classifier" def : incompGenerals : Sequence(UML2!"uml::Classifier") = 
	UML2!"uml::Classifier".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->select(e|e.umlQualifiedName=self.umlQualifiedName)
		->collect(p|p.allGeneralsIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::Classifier" def : incompFeatures : Sequence(UML2!"uml::Feature") = 
	UML2!"uml::Classifier".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->select(e|e.umlQualifiedName=self.umlQualifiedName)
		->collect(p|p.allFeaturesIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::NamedElement" def : incompSuppliers : Sequence(UML2!"uml::NamedElement") = 
	UML2!"uml::NamedElement".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->select(e|e.umlQualifiedName=self.umlQualifiedName)
		->collect(p|p.allSuppliersIncompatibleWith(self))
		->flatten();

helper context UML2!"uml::NamedElement" def : compatibleNameAndTypeFromIn : Sequence(UML!"uml::NamedElement") =
	UML2!"uml::NamedElement".allInstancesFrom('IN')
		->reject(e|e.isDerived)
		->select(n|n.umlQualifiedName=self.umlQualifiedName and n.myOclType.conformsTo(self.myOclType));

helper context UML2!"ecore::EObject" def : isMissing : Boolean =
	false;

helper context UML2!"ecore::EStringToStringMapEntry" def : isMissing : Boolean =
	false;

helper context UML2!"uml::Package" def : isMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		if self.hasMissingOwner then true else
			self.getModel().locallyIncompPacks->includes(self)
		endif
	else false endif;

helper context UML2!"uml::Class" def : isMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		if self.hasMissingOwner then true else
			self.getNearestPackage().locallyIncompClasses->includes(self)
		endif
	else false endif;

helper context UML2!"uml::Interface" def : isMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		if self.hasMissingOwner then true else
			self.getNearestPackage().locallyIncompClasses->includes(self)
		endif
	else false endif;

helper context UML2!"uml::Generalization" def : isMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		if self.specific.isMissing then true else
			self.specific.incompGenerals->includes(self.general)
		endif
	else false endif;

helper context UML2!"uml::InterfaceRealization" def : isMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		if self.implementingClassifier.isMissing then true else
			self.implementingClassifier.incompSuppliers->exists(i|self.supplier->includes(i))
		endif
	else false endif;

helper context UML2!"uml::Property" def : isMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		if self.hasMissingOwner then true else
			if self.class.oclIsUndefined() then false else
				self.class.incompFeatures->includes(self)
			endif
		endif
	else false endif;

helper context UML2!"uml::Operation" def : isMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		if self.hasMissingOwner then true else
			if self.class.oclIsUndefined() then
				if self.interface.oclIsUndefined() then false else
					self.interface.incompFeatures->includes(self)
				endif
			else
				self.class.incompFeatures->includes(self)
			endif
		endif
	else false endif;

helper context UML2!"uml::Parameter" def : isMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		if self.operation.oclIsUndefined() then false else
			self.operation.isMissing
		endif
	else false endif;

helper context UML2!"uml::LiteralUnlimitedNatural" def : isMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		self.refImmediateComposite().isMissing
	else false endif;

helper context UML2!"uml::LiteralInteger" def : isMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		self.refImmediateComposite().isMissing
	else false endif;

helper context UML2!"uml::Element" def : hasElementsMissing : Boolean =
	false;

helper context UML2!"uml::Package" def : hasElementsMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		if self.hasMissingOwner then false else
			(self.getModel().incompPacks->includes(self) or
		 	self.getModel().incompPacks->exists(p|self.allOwnedPackages->includes(p)))
		endif
	else false endif;

helper context UML2!"uml::Class" def : hasElementsMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		if self.hasMissingOwner then false else
			let pack : UML2!"uml::Package" = self.getNearestPackage() in
			(pack.incompClasses->includes(self) or
		 	pack.incompClasses->exists(c|self.allOwnedClassifiers->includes(c)))
		endif
	else false endif;

helper context UML2!"uml::Interface" def : hasElementsMissing : Boolean =
	if thisModule.depsElements->includes(self) then
		if self.hasMissingOwner then false else
			let pack : UML2!"uml::Package" = self.getNearestPackage() in
			(pack.incompClasses->includes(self) or
		 	pack.incompClasses->exists(c|self.allOwnedClassifiers->includes(c)))
		endif
	else false endif;

helper context UML2!"uml::Element" def : hasMissingOwner : Boolean =
	if self.owner.oclIsUndefined() then false else
		if self.owner.isMissing then true else
			self.owner.hasMissingOwner
		endif
	endif;

helper context UML2!"uml::Element" def : isReferred : Boolean =
	false;

helper context UML2!"uml::Classifier" def : isReferred : Boolean =
	thisModule.depsElements
	->exists(e|
		if e.isMissing then
			e.refersToType(self)
		else false endif);

helper context UML2!"uml::Element" def : hasReferredTypes : Boolean =
	false;

helper context UML2!"uml::Package" def : hasReferredTypes : Boolean =
	self.packagedElement
	->exists(e|e.isReferred or e.hasReferredTypes);

helper context UML2!"uml::Class" def : hasReferredTypes : Boolean =
	self.nestedClassifier
	->exists(e|e.isReferred);

helper context UML2!"uml::Interface" def : hasReferredTypes : Boolean =
	self.nestedClassifier
	->exists(e|e.isReferred);

helper context UML2!"uml::Classifier" def : isIncludedInReport : Boolean =
	self.isMissing or
	self.hasElementsMissing or
	self.isReferred or
	self.hasReferredTypes;

-- ======================================================================
-- helper attributes end
-- ======================================================================

-- ======================================================================
-- helper methods begin
-- ======================================================================

helper context OclAny def : join(separator : String) : String =
	if self.oclIsKindOf(Sequence(OclAny)) then
		self->iterate(e; acc : String = '' |
			if acc = '' then acc + e.toString()
			else acc + separator + e endif)
	else '' endif;

helper context UML2!"uml::Element" def : refersToType(type : UML2!"uml::Type") : Boolean =
	false;

helper context UML2!"uml::Property" def : refersToType(type : UML2!"uml::Type") : Boolean =
	self.type=type;

helper context UML2!"uml::Parameter" def : refersToType(type : UML2!"uml::Type") : Boolean =
	self.type=type;

helper context UML2!"uml::Generalization" def : refersToType(type : UML2!"uml::Type") : Boolean =
	self.general=type;

helper context UML2!"uml::InterfaceRealization" def : refersToType(type : UML2!"uml::Type") : Boolean =
	self.contract=type;

-- ======================================================================
-- helper methods end
-- ======================================================================

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule Model {
	from s : UML2!"uml::Model" (thisModule.depsElements->includes(s))
	using {
		provides : String = UML2!"uml::Model".allInstancesFrom('IN')
			->collect(m|m.name)
			->join(', ');
	}
    to t : UML2!"uml::Model" (
        name <- (provides + ' provides ' + s.name.toString()).debug('Creating compatibility report'),
		eAnnotations <- s.eAnnotations,
        packagedElement <- s.packagedElement)
	do {
		t.applyProfile(thisModule.crProfile);
		t.applyStereotype(thisModule.stCompatibilityReport);
	}
}

rule EAnnotation {
    from s : UML2!"ecore::EAnnotation" (thisModule.depsElements->includes(s))
    to t : UML2!"ecore::EAnnotation" (
        source <- s.source,
        eAnnotations <- s.eAnnotations,
        details <- s.details,
        contents <- s.contents,
        references <- s.references)
}

rule EStringToStringMapEntry {
    from s : UML2!"ecore::EStringToStringMapEntry" (thisModule.depsElements->includes(s))
    to t : UML2!"ecore::EStringToStringMapEntry" (
        key <- s.key,
        value <- s.value)
}

rule Package {
	from s : UML2!"uml::Package" (
		if s.oclIsTypeOf(UML2!"uml::Package") then
			if s.isMissing then false else
				if s.hasElementsMissing then false else
					s.hasReferredTypes
				endif
			endif
		else false endif)
    to t : UML2!"uml::Package" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        packagedElement <- s.packagedElement)
}

rule IncompatiblePackage {
	from s : UML2!"uml::Package" (
		if s.oclIsTypeOf(UML2!"uml::Package") then
			if s.isMissing then false else
				s.hasElementsMissing
			endif
		else false endif)
    to t : UML2!"uml::Package" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        packagedElement <- s.packagedElement)
	do {
		t.applyStereotype(thisModule.stIncompatible);
	}
}

rule MissingPackage {
	from s : UML2!"uml::Package" (
		if s.oclIsTypeOf(UML2!"uml::Package") then
			s.isMissing
		else false endif)
    to t : UML2!"uml::Package" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        packagedElement <- s.packagedElement)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule Class {
    from s : UML2!"uml::Class" (
    	if s.oclIsTypeOf(UML2!"uml::Class") then
			if s.isMissing then false else
				if s.hasElementsMissing then false else
					s.hasReferredTypes or
					s.isReferred
				endif
			endif
		else false endif)
    to t : UML2!"uml::Class" (
        name <- s.name.debug('>>Class<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        generalization <- s.generalization,
		ownedAttribute <- s.ownedAttribute,
        interfaceRealization <- s.interfaceRealization,
		nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation)
}

rule IncompatibleClass {
    from s : UML2!"uml::Class" (
    	if s.oclIsTypeOf(UML2!"uml::Class") then
			if s.isMissing then false else
				s.hasElementsMissing
			endif
		else false endif)
    to t : UML2!"uml::Class" (
        name <- s.name.debug('>>IncompatibleClass<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        generalization <- s.generalization,
		ownedAttribute <- s.ownedAttribute,
        interfaceRealization <- s.interfaceRealization,
		nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation)
	do {
		t.applyStereotype(thisModule.stIncompatible);
	}
}

rule MissingClass {
    from s : UML2!"uml::Class" (
    	if s.oclIsTypeOf(UML2!"uml::Class") then
			s.isMissing
		else false endif)
    to t : UML2!"uml::Class" (
        name <- s.name.debug('>>MissingClass<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        isActive <- s.isActive,
        generalization <- s.generalization,
		ownedAttribute <- s.ownedAttribute,
        interfaceRealization <- s.interfaceRealization,
		nestedClassifier <- s.nestedClassifier,
        ownedOperation <- s.ownedOperation)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule Interface {
    from s : UML2!"uml::Interface" (
    	if s.isMissing then false else
    		if s.hasElementsMissing then false else
				s.hasReferredTypes or
				s.isReferred
			endif
		endif)
	to t : UML2!"uml::Interface" (
        name <- s.name.debug('>>Interface<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization,
        ownedOperation <- s.ownedOperation,
        nestedClassifier <- s.nestedClassifier)
}

rule IncompatibleInterface {
    from s : UML2!"uml::Interface" (
    	if s.isMissing then false else
    		s.hasElementsMissing
		endif)
	to t : UML2!"uml::Interface" (
        name <- s.name.debug('>>IncompatibleInterface<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization,
        ownedOperation <- s.ownedOperation,
        nestedClassifier <- s.nestedClassifier)
	do {
		t.applyStereotype(thisModule.stIncompatible);
	}
}

rule MissingInterface {
    from s : UML2!"uml::Interface" (s.isMissing)
	to t : UML2!"uml::Interface" (
        name <- s.name.debug('>>MissingInterface<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization,
        ownedOperation <- s.ownedOperation,
        nestedClassifier <- s.nestedClassifier)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule DataType {
    from s : UML2!"uml::DataType" (
    	if s.oclIsTypeOf(UML2!"uml::DataType") then
		   	if s.isMissing then false else
				s.isReferred
			endif
		else false endif)
	to t : UML2!"uml::DataType" (
        name <- s.name.debug('>>DataType<< ' + s.qualifiedName),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization)
}

rule MissingDataType {
    from s : UML2!"uml::DataType" (
    	if s.oclIsTypeOf(UML2!"uml::DataType") then
    		s.isMissing
		else false endif)
	to t : UML2!"uml::DataType" (
        name <- s.name.debug('>>MissingDataType<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule PrimitiveType {
    from s : UML2!"uml::PrimitiveType" (
    	if s.isMissing then false else
			s.isReferred
		endif)
	to t : UML2!"uml::PrimitiveType" (
        name <- s.name.debug('>>PrimitiveType<< ' + s.qualifiedName),
        visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization)
}

rule MissingPrimitiveType {
    from s : UML2!"uml::PrimitiveType" (s.isMissing)
	to t : UML2!"uml::PrimitiveType" (
        name <- s.name.debug('>>MissingPrimitiveType<< ' + s.qualifiedName),
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isAbstract <- s.isAbstract,
        generalization <- s.generalization)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule Generalization {
    from s : UML2!"uml::Generalization" (
    	if s.isMissing then false else
    		s.specific.isIncludedInReport and
			s.general.isIncludedInReport
    	endif)
    to t : UML2!"uml::Generalization" (
		eAnnotations <- s.eAnnotations,
    	general <- s.general)
}

rule MissingGeneralization {
    from s : UML2!"uml::Generalization" (s.isMissing)
    to t : UML2!"uml::Generalization" (
		eAnnotations <- s.eAnnotations,
    	general <- s.general)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule InterfaceRealization {
    from s : UML2!"uml::InterfaceRealization" (
    	if s.isMissing then false else
    		s.contract.isIncludedInReport and
			s.implementingClassifier.isIncludedInReport
    	endif)
    to t : UML2!"uml::InterfaceRealization" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
		supplier <- s.supplier,
        client <- s.client,
        contract <- s.contract)
}

rule MissingInterfaceRealization {
    from s : UML2!"uml::InterfaceRealization" (s.isMissing)
    to t : UML2!"uml::InterfaceRealization" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
		supplier <- s.supplier,
        client <- s.client,
        contract <- s.contract)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule MissingProperty {
    from s : UML2!"uml::Property" (
    	if s.oclIsTypeOf(UML2!"uml::Property") then
			s.isMissing
		else false endif)
    to t : UML2!"uml::Property" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        isReadOnly <- s.isReadOnly,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule LiteralUnlimitedNatural {
    from s : UML2!"uml::LiteralUnlimitedNatural" (s.isMissing)
    to t : UML2!"uml::LiteralUnlimitedNatural" (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value)
}

rule LiteralInteger {
    from s : UML2!"uml::LiteralInteger" (s.isMissing)
    to t : UML2!"uml::LiteralInteger" (
        name <- s.name,
        visibility <- s.visibility,
        value <- s.value)
}

rule MissingOperation {
    from s : UML2!"uml::Operation" (s.isMissing)
    to t : UML2!"uml::Operation" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isLeaf <- s.isLeaf,
        isStatic <- s.isStatic,
        isAbstract <- s.isAbstract,
        concurrency <- s.concurrency,
        isQuery <- s.isQuery,
        ownedParameter <- s.ownedParameter,
        raisedException <- s.raisedException)
	do {
		t.applyStereotype(thisModule.stMissing);
	}
}

rule Parameter {
    from s : UML2!"uml::Parameter" (s.isMissing)
    to t : UML2!"uml::Parameter" (
        name <- s.name,
		eAnnotations <- s.eAnnotations,
		visibility <- s.visibility,
        isOrdered <- s.isOrdered,
        isUnique <- s.isUnique,
        direction <- s.direction,
        isException <- s.isException,
        isStream <- s.isStream,
        type <- s.type,
        upperValue <- s.upperValue,
        lowerValue <- s.lowerValue)
}

endpoint rule UML2CompatibilityComparison() {
	do {
		UML2!"uml::Model".allInstancesFrom('IN')
			->collect(m|m.compatibleInPrev)->flatten()->notEmpty()
			.debug('Model is compatible with previous model');
	}
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
