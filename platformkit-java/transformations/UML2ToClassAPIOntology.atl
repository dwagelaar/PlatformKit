-- @atlcompiler atl2006
-- $Id$
-- Transforms a UML2 model to an API OWL ontology containing all the packages and classifiers
module UML2ToClassAPIOntology; --extends UML2ToAPIOntology

create OUT : OWL from IN : UML2, PLATFORM : OWL, JAVA : OWL;

uses UML2ToAPIOntology;

-- ======================================================================
-- helper attributes begin
-- ======================================================================

helper def : UML2ToClassAPIOntologyVersionString : String =
	'$Id$';

helper def : includedClassifiers : Set(UML2!uml::Classifier) =  UML2!uml::Classifier->allInstancesFrom('IN')
	->select(c|c->oclIsKindOf(UML2!uml::Class) or c->oclIsKindOf(UML2!uml::Interface));

-- ======================================================================
-- helper attributes end
-- ======================================================================

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule Model {
	from s : UML2!uml::Model (thisModule.inElements->includes(s))
	using {
		prevNotEmpty : Boolean = thisModule.prevModels->select(m|m.packagedElement->notEmpty())->notEmpty();
		superClasses : Sequence(OWL!owl::OWLClass) = s.compatibleClasses->select(c|s.equivalentClasses->excludes(c));
	}
	to n : OWL!rdfs::Namespace mapsTo s (
		URI <- 'http://ssel.vub.ac.be/platformkit/' + s.name + '#',
		name <- s.name),
	   xsd : OWL!rdfs::Namespace (
	   	URI <- 'http://www.w3.org/2001/XMLSchema#',
		name <- 'xsd'),
	   units : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Units.owl#',
		name <- 'units'),
	   platform : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Platform.owl#',
		name <- 'platform'),
	   java : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Java.owl#',
		name <- 'java'),
	   ont : OWL!owl::OWLOntology (
	   	localName <- '',
		namespace <- n,
		RDFSLabel <- Sequence{label},
		RDFSComment <- Sequence{comment},
		ownedNamespace <- Set{n, xsd, units, platform, java}->union(
			if prevNotEmpty	then thisModule.importedOntologies->collect(o|thisModule->PrevNamespace(o)) else Set{} endif),
-- !!! OWLImports generates bogus namespace !!!
		OWLImports <- thisModule.platformOntology->union(thisModule.javaOntology)->union(
			if prevNotEmpty then thisModule.importedOntologies else Set{} endif),
		contains <- Sequence{apiClass, jreClass}->union(
			thisModule.includedPackages)->union(
			thisModule.includedClassifiers)),
	   label : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- s.name),
	   comment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'Generated by ' + 
			thisModule.UML2ToClassAPIOntologyVersionString + ' and ' + 
			thisModule.UML2ToAPIOntologyVersionString + ' and ' +
			thisModule.UML2ComparisonVersionString),
	   apiClass : OWL!owl::OWLClass (
	   	localName <- s.name->firstToUpper() + 'ClassLibrary',
		RDFSSubClassOf <- thisModule.includedPackages->union(superClasses),
		OWLEquivalentClass <- s.equivalentClasses,
		RDFSComment <- Sequence{apiComment},
		namespace <- s),
	   apiComment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'JavaLibrary implementing the entire API for ' + s.name),
	   jreClass : OWL!owl::OWLClass (
	   	localName <- s.name->firstToUpper(),
		RDFSSubClassOf <- Sequence{thisModule.javaJRE, builtinJavaLibraryRestriction},
		RDFSComment <- Sequence{jreComment},
		namespace <- s),
	   jreComment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- s.name + ' Java Runtime Environment'),
	   builtinJavaLibraryRestriction : OWL!owl::SomeValuesFromRestriction (
	   	OWLOnProperty <- thisModule.jreProvidesBuiltinJavaLibrary,
		OWLSomeValuesFrom <- apiClass,
		namespace <- s)
}

rule Package {
	from s : UML2!uml::Package (thisModule.includedPackages->includes(s))
	using {
		superClasses : Sequence(OWL!owl::OWLClass) = s.compatibleClasses->select(c|s.equivalentClasses->excludes(c));
	}
	to t : OWL!owl::OWLClass mapsTo s (
		localName <- (s.ontClassName + 'Library')->debug(thisModule.modelName.prefix + 'Package'),
		RDFSSubClassOf <- s.allOwnedClassifiers->union(superClasses),
		OWLEquivalentClass <- s.equivalentClasses,
		RDFSComment <- Sequence{comment},
		RDFSSeeAlso <- s.references,
		namespace <- s->getModel()),
	   comment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'JavaLibrary implementing the ' + s.javaQualifiedName + ' package for ' + thisModule.modelName)
}

rule Classifier {
	from s : UML2!uml::Classifier (thisModule.includedClassifiers->includes(s))
	using {
		superClasses : Sequence(OWL!owl::OWLClass) = s.compatibleClasses->select(c|s.equivalentClasses->excludes(c));
	}
	to t : OWL!owl::OWLClass mapsTo s (
		localName <- (s.ontClassName + 'Library')->debug(thisModule.modelName.prefix + 'Classifier'),
		RDFSSubClassOf <- if superClasses->isEmpty()
			then thisModule.javaLibrary else superClasses endif,
		OWLEquivalentClass <- s.equivalentClasses,
		RDFSComment <- Sequence{comment},
		RDFSSeeAlso <- s.references,
		namespace <- s->getModel()),
	   comment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'JavaLibrary implementing the ' + s.javaQualifiedName + ' classifier for ' + thisModule.modelName)
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
