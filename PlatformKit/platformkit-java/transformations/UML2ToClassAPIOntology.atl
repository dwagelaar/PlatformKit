-- @atlcompiler atl2006
-- $Id$
-- Transforms a UML2 model to an API OWL ontology containing all the packages and classifiers
module UML2ToClassAPIOntology; --extends UML2ToAPIOntology

create OUT : OWL from IN : UML2, PLATFORM : OWL, JAVA : OWL;

uses UML2ToAPIOntology;

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule Model {
	from s : UML2!uml::Model (thisModule.inElements->includes(s))
	using {
		prevNotEmpty : Boolean = thisModule.prevModels->select(m|m.packagedElement->notEmpty())->notEmpty();
	}
	to n : OWL!rdfs::Namespace mapsTo s (
		URI <- 'http://ssel.vub.ac.be/platformkit/' + s.name + '#',
		name <- s.name),
	   xsd : OWL!rdfs::Namespace (
	   	URI <- 'http://www.w3.org/2001/XMLSchema#',
		name <- 'xsd'),
	   units : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Units.owl#',
		name <- 'units'),
	   platform : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Platform.owl#',
		name <- 'platform'),
	   java : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Java.owl#',
		name <- 'java'),
	   ont : OWL!owl::OWLOntology (
	   	localName <- '',
		namespace <- n,
		RDFSLabel <- Sequence{label},
		RDFSComment <- Sequence{comment},
		ownedNamespace <- Set{n, xsd, units, platform, java}->union(
			if prevNotEmpty	then thisModule.importedOntologies->collect(o|thisModule->PrevNamespace(o)) else Set{} endif),
-- !!! OWLImports generates bogus namespace !!!
		OWLImports <- thisModule.platformOntology->union(thisModule.javaOntology)->union(
			if prevNotEmpty then thisModule.importedOntologies else Set{} endif),
		contains <- Sequence{apiClass, jreClass}->union(
			thisModule.includedPackages)->union(
			thisModule.includedPackages->collect(p|
				thisModule->resolveTemp(p, 'platform')))->union(
			thisModule.includedClassifiers)->union(
			thisModule.includedClassifiers->collect(c|
				thisModule->resolveTemp(c, 'platform')))),
	   label : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- s.name),
	   comment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'Generated by $Id$'),
	   apiClass : OWL!owl::OWLClass (
	   	localName <- s.name->firstToUpper() + 'ClassLibrary',
		RDFSSubClassOf <- thisModule.includedPackages,
		RDFSComment <- Sequence{apiComment},
		namespace <- s),
	   apiComment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'JavaLibrary implementing the entire API for ' + s.name),
	   jreClass : OWL!owl::OWLClass (
	   	localName <- s.name->firstToUpper(),
		RDFSSubClassOf <- Sequence{thisModule.javaJRE, builtinJavaLibraryRestriction},
		RDFSComment <- Sequence{jreComment},
		namespace <- s),
	   jreComment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- s.name + ' Java Runtime Environment'),
	   builtinJavaLibraryRestriction : OWL!owl::SomeValuesFromRestriction (
	   	OWLOnProperty <- thisModule.jreProvidesBuiltinJavaLibrary,
		OWLSomeValuesFrom <- apiClass,
		namespace <- s)
}

rule Package {
	from s : UML2!uml::Package (thisModule.includedPackages->includes(s))
	using {
		refs : Set(UML2!uml::Package) = s.references->debug(s.qualifiedName + ' referenced packages');
		compatiblePacks : Sequence(UML2!uml::Package) = s.compatibleInPrev->debug(s.qualifiedName + ' compatible packages');
		equivalentPacks : Sequence(UML2!uml::Package) = compatiblePacks->select(p|p->isCompatibleWith(s))->debug(s.qualifiedName + ' equivalent packages');
		compatibleClasses : Sequence(OWL!owl::OWLClass) = compatiblePacks->collect(p|p.owlClassesInPrev)->flatten();
		equivalentClasses : Sequence(OWL!owl::OWLClass) = equivalentPacks->collect(p|p.owlClassesInPrev)->flatten();
		superClasses : Sequence(OWL!owl::OWLClass) = compatibleClasses->select(c|equivalentClasses->excludes(c));
	}
	to t : OWL!owl::OWLClass mapsTo s (
		localName <- (s.ontClassName + 'Library')->debug('Package'),
		RDFSSubClassOf <- s.allOwnedClassifiers->union(superClasses),
		OWLEquivalentClass <- if equivalentClasses->isEmpty()
			then Sequence{} else equivalentClasses endif,
		RDFSComment <- Sequence{comment},
		RDFSSeeAlso <- refs,
		namespace <- s->getModel()),
	   comment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'JavaLibrary implementing the ' + s.javaQualifiedName + ' package for ' + s->getModel().name),
	   platform : OWL!owl::OWLClass (
	   	localName <- (s.ontClassName + 'Platform'),
		RDFSSubClassOf <- thisModule.platformPlatform,
		RDFSComment <- Sequence{platformcomment},
		OWLEquivalentClass <- Sequence{intersection},
		namespace <- s->getModel()),
	   platformcomment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'Platform providing ' + comment.lexicalForm),
	   intersection : OWL!owl::IntersectionClass (
	   	OWLIntersectionOf <- Set{restriction},
	   	namespace <- s->getModel()),
	   restriction : OWL!owl::SomeValuesFromRestriction (
		OWLOnProperty <- thisModule.platformProvidesFeature,
		OWLSomeValuesFrom <- s,
		namespace <- s->getModel())
}

rule Classifier {
	from s : UML2!uml::Classifier (thisModule.includedClassifiers->includes(s))
	using {
		refs : Set(UML2!uml::Classifier) = s.references->debug(s.qualifiedName + ' referenced classifiers');
		compatibleClassifiers : Sequence(UML2!uml::Classifier) = s.compatibleInPrev->debug(s.qualifiedName + ' compatible classifiers');
		equivalentClassifiers : Sequence(UML2!uml::Classifier) = compatibleClassifiers->select(p|p->isCompatibleWith(s))->debug(s.qualifiedName + ' equivalent classifiers');
		compatibleClasses : Sequence(OWL!owl::OWLClass) = compatibleClassifiers->collect(p|p.owlClassesInPrev)->flatten();
		equivalentClasses : Sequence(OWL!owl::OWLClass) = equivalentClassifiers->collect(p|p.owlClassesInPrev)->flatten();
		superClasses : Sequence(OWL!owl::OWLClass) = compatibleClasses->select(c|equivalentClasses->excludes(c));
	}
	to t : OWL!owl::OWLClass mapsTo s (
		localName <- (s.ontClassName + 'Library')->debug('Classifier'),
		RDFSSubClassOf <- if superClasses->isEmpty()
			then thisModule.javaLibrary else superClasses endif,
		OWLEquivalentClass <- if equivalentClasses->isEmpty()
			then Sequence{} else equivalentClasses endif,
		RDFSComment <- Sequence{comment},
		RDFSSeeAlso <- refs,
		namespace <- s->getModel()),
	   comment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'JavaLibrary implementing the ' + s.javaQualifiedName + ' classifier for ' + s->getModel().name),
	   platform : OWL!owl::OWLClass (
	   	localName <- (s.ontClassName + 'Platform'),
		RDFSSubClassOf <- thisModule.platformPlatform,
		RDFSComment <- Sequence{platformcomment},
		OWLEquivalentClass <- Sequence{intersection},
		namespace <- s->getModel()),
	   platformcomment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'Platform providing ' + comment.lexicalForm),
	   intersection : OWL!owl::IntersectionClass (
	   	OWLIntersectionOf <- Set{restriction},
	   	namespace <- s->getModel()),
	   restriction : OWL!owl::SomeValuesFromRestriction (
		OWLOnProperty <- thisModule.platformProvidesFeature,
		OWLSomeValuesFrom <- s,
		namespace <- s->getModel())
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
