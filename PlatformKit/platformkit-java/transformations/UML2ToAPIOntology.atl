-- @atlcompiler atl2006
-- $Id$
-- Transforms a UML2 model to an API OWL ontology containing all the packages
module UML2ToAPIOntology;

create OUT : OWL from IN : UML2, PLATFORM : OWL, JAVA : OWL, PREVOUT : OWL, PREVIN : UML2;

-- ======================================================================
-- helper attributes begin
-- ======================================================================

helper def : inElements : Set(UML2!ecore::EObject) = UML2!ecore::EObject->allInstancesFrom('IN');

helper def : includedPackages : Set(UML2!uml::Package) = UML2!uml::Package->allInstancesFrom('IN')
	->select(p|p->oclIsTypeOf(UML2!uml::Package) and p.packagedElement
		->select(p2|not p2->oclIsKindOf(UML2!uml::Package))->notEmpty());

helper def : platformPlatform : Set(OWL!owl::OWLClass) = OWL!owl::OWLClass->allInstancesFrom('PLATFORM')
	->select(o|o.localName = 'Platform');

helper def : javaLibrary : Set(OWL!owl::OWLClass) = OWL!owl::OWLClass->allInstancesFrom('JAVA')
	->select(o|o.localName = 'JavaLibrary');

helper def : platformProvidesFeature : OWL!owl::OWLObjectProperty =
	OWL!owl::OWLObjectProperty->allInstancesFrom('PLATFORM')
		->select(p|p.localName = 'providesFeature')->first();

helper def : platformOntology : Set(OWL!owl::OWLOntology) = 
	OWL!owl::OWLOntology->allInstancesFrom('PLATFORM');

helper def : javaOntology : Set(OWL!owl::OWLOntology) = 
	OWL!owl::OWLOntology->allInstancesFrom('JAVA');

helper def : prevOntology : Set(OWL!owl::OWLOntology) = 
	OWL!owl::OWLOntology->allInstancesFrom('PREVOUT');

helper def : prevModel : Set(UML2!uml::Model) = 
	UML2!uml::Model->allInstancesFrom('PREVIN');

-- ======================================================================
-- helper attributes end
-- ======================================================================

-- ======================================================================
-- helper methods begin
-- ======================================================================

helper context UML2!uml::NamedElement def : qualifiedName(separator : String) : String =
	if self.owner->oclIsTypeOf(UML2!uml::Package) then
		self.owner->qualifiedName(separator) + separator + self.name
	else
		self.name
	endif;

helper context String def: firstToUpper() : String =
	self->substring(1, 1)->toUpper() + self->substring(2, self->size());

helper context UML2!uml::NamedElement def : ontClassName() : String =
	if self.owner->oclIsTypeOf(UML2!uml::Package) then
		self.owner->ontClassName() + self.name->firstToUpper()
	else
		self.name->firstToUpper()
	endif;

helper context UML2!uml::Package def : references() : Set(UML2!uml::Package) =
	self.packagedElement->collect(p|p->referencesOtherThan(self))->flatten()->asSet();

helper context UML2!uml::PackageableElement def : referencesOtherThan(p : UML2!uml::Package) : Set(UML2!uml::Package) =
	Set{};

helper context UML2!uml::Classifier def : referencesOtherThan(p : UML2!uml::Package) : Set(UML2!uml::Package) =
	(if self->getNearestPackage() <> p then Set{self->getNearestPackage()} else Set{} endif)->union(
	self->parents()->collect(c|c->referencesOtherThan(p))->flatten());

helper context UML2!uml::Package def : owlClassesInPrev() : Sequence(OWL!owl::OWLClass) =
	OWL!owl::OWLClass->allInstancesFrom('PREVOUT')->select(c|c.localName = self->ontClassName());

helper context UML2!uml::Package def : compatibleInPrev() : Sequence(UML2!uml::Package) =
	UML2!uml::Package->allInstancesFrom('PREVIN')->select(p|self->isCompatibleWith(p));

helper context UML2!uml::Classifier def : isCompatibleWith(c : UML2!uml::Classifier) : Boolean =
	if self->namedElementIsCompatibleWith(c)
	then (let compGenerals : Sequence(UML2!uml::Classifier) = c.general->select(g|not self->hasGeneralCompatibleWith(g))
		  in if compGenerals->isEmpty() then true
		  	 else compGenerals->debug(self.qualifiedName + ' misses generals compatible with ')->isEmpty() endif) and
		 (let compFeatures : Sequence(UML2!uml::Feature) = c->allFeatures()->select(f|not self->hasFeatureCompatibleWith(f))
		  in if compFeatures->isEmpty() then true
		  	 else compFeatures->debug(self.qualifiedName + ' misses features compatible with ')->isEmpty() endif)
	else false endif;

helper context UML2!uml::Classifier def : hasFeatureCompatibleWith(f : UML2!uml::Feature) : Boolean =
	self->allFeatures()->select(o|o->isCompatibleWith(f))->notEmpty();

helper context UML2!uml::StructuralFeature def : isCompatibleWith(f : UML2!uml::StructuralFeature) : Boolean =
	if self->typedElementIsCompatibleWith(f)
	then (self.isStatic = f.isStatic) and
		 (self.isReadOnly = f.isReadOnly)
	else false endif;

helper context UML2!uml::BehavioralFeature def : isCompatibleWith(f : UML2!uml::BehavioralFeature) : Boolean =
	if self->namedElementIsCompatibleWith(f)
	then (self.isStatic = f.isStatic) and
		 (if self.isAbstract then f.isAbstract else true endif)
	else false endif;

helper context UML2!uml::Parameter def : isCompatibleWith(p : UML2!uml::Parameter) : Boolean =
	if p->oclIsUndefined() then true
	else
		if self->typedElementIsCompatibleWith(p)
		then (self.direction = p.direction)
		else false endif
	endif;

helper context UML2!uml::TypedElement def : isCompatibleWith(t : UML2!uml::TypedElement) : Boolean =
	self->typedElementIsCompatibleWith(t);
	
helper context UML2!uml::NamedElement def : isCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	self->namedElementIsCompatibleWith(e);

helper context UML2!uml::NamedElement def : visibilityIsCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	if (self.visibility = #public) then true
	else if (self.visibility = #protected) then (e.visibility = #protected) or (e.visibility = #private)
	else if (self.visibility = #package) then (e.visibility = #package) or (e.visibility = #private)
	else (self.visibility = e.visibility) endif endif endif;

helper context UML2!uml::TypedElement def : typedElementIsCompatibleWith(t : UML2!uml::TypedElement) : Boolean =
	if self->namedElementIsCompatibleWith(t)
	then if self.type->oclIsUndefined()
		 then t.type->oclIsUndefined()
		 else if t.type->oclIsUndefined()
		 	  then false
			  else (self.type->qualifiedName('::') = t.type->qualifiedName('::')) endif endif
	else false endif;
	
helper context UML2!uml::NamedElement def : namedElementIsCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	if (self->qualifiedName('::') = e->qualifiedName('::')) and (self->oclType() = e->oclType()) and (self->visibilityIsCompatibleWith(e))
	then (let ownedComp : Sequence(UML2!uml::NamedElement) = e->ownedNamed()->select(o|not self->containsElementCompatibleWith(o))
		  in if ownedComp->isEmpty() then true 
		  	 else if self->oclIsKindOf(UML2!uml::Package)
			 	  then ownedComp->debug(self.qualifiedName + ' misses elements compatible with ')->isEmpty()
			      else false endif endif) and
		 (let compSuppliers : Sequence(UML2!uml::NamedElement) = e->suppliers()->select(d|not self->hasSupplierCompatibleWith(d))
		  in if compSuppliers->isEmpty() then true
		  	 else compSuppliers->debug(self.qualifiedName + ' misses dependency suppliers compatible with ')->isEmpty() endif)
	else false endif;

helper context UML2!uml::Element def : containsElementCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	self->ownedNamed()->select(o|o->isCompatibleWith(e))->notEmpty();

helper context UML2!uml::Classifier def : hasGeneralCompatibleWith(c : UML2!uml::Classifier) : Boolean =
	self.general->select(g|if (g->qualifiedName('::') = c->qualifiedName('::')) then true else g->hasGeneralCompatibleWith(c) endif)->notEmpty();

helper context UML2!uml::Classifier def : hasSupplierCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	if self->namedElementHasSupplierCompatibleWith(e) then true
	else self.general->select(g|g.hasSupplierCompatibleWith(e))->notEmpty() endif;

helper context UML2!uml::NamedElement def : hasSupplierCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	self->namedElementHasSupplierCompatibleWith(e);

helper context UML2!uml::NamedElement def : namedElementHasSupplierCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	self->allSuppliers()
		->select(s|(s->qualifiedName('::') = e->qualifiedName('::')))->notEmpty();

helper context UML2!uml::NamedElement def : suppliers() : Set(UML2!uml::NamedElement) =
	self.clientDependency->collect(d|d.supplier
			->select(n|not n.name->oclIsUndefined())
		)->flatten()->asSet();

helper context UML2!uml::NamedElement def : allSuppliers() : Set(UML2!uml::NamedElement) =
	self.clientDependency->collect(d|d.supplier
			->union(d.supplier->collect(s1|s1.allSuppliers())->flatten())
			->select(n|not n.name->oclIsUndefined())
		)->flatten()->asSet();

helper context UML2!uml::Element def : ownedNamed() : Sequence(UML2!uml::NamedElement) =
	self.ownedElement
		->select(o|o->oclIsKindOf(UML2!uml::NamedElement) and 
			       (not o->oclIsKindOf(UML2!uml::Package)) and
				   (not o->oclIsKindOf(UML2!uml::Feature)))
		->select(n|not n.name->oclIsUndefined());

-- ======================================================================
-- helper methods end
-- ======================================================================

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule Model {
	from s : UML2!uml::Model (thisModule.inElements->includes(s))
	using {
		prevNotEmpty : Boolean = thisModule.prevModel->select(m|m.packagedElement->notEmpty())->notEmpty();
	}
	to n : OWL!rdfs::Namespace mapsTo s (
		URI <- 'http://ssel.vub.ac.be/platformkit/' + s.name + '#',
		name <- s.name),
	   xsd : OWL!rdfs::Namespace (
	   	URI <- 'http://www.w3.org/2001/XMLSchema#',
		name <- 'xsd'),
	   units : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Units.owl#',
		name <- 'units'),
	   platform : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Platform.owl#',
		name <- 'platform'),
	   java : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Java.owl#',
		name <- 'java'),
	   ont : OWL!owl::OWLOntology (
	   	localName <- '',
		namespace <- n,
		RDFSLabel <- Sequence{label},
		RDFSComment <- Sequence{comment},
		ownedNamespace <- Set{n, xsd, units, platform, java}->union(
			if prevNotEmpty	then thisModule.prevOntology->collect(o|thisModule->PrevNamespace(o)) else Set{} endif),
-- !!! OWLImports generates bogus namespace !!!
		OWLImports <- thisModule.platformOntology->union(thisModule.javaOntology)->union(
			if prevNotEmpty	then thisModule.prevOntology else Set{} endif),
		contains <- thisModule.includedPackages->union(
			thisModule.includedPackages->collect(p|
				thisModule->resolveTemp(p, 'platform')))),
	   label : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- s.name),
	   comment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'Generated by $Id$')
}

rule PrevNamespace(o : OWL!owl::OWLOntology) {
	to n : OWL!rdfs::Namespace (
		URI <- o.namespace.URI,
		name <- o.namespace.name)
	do {
		n;
	}
}

rule Package {
	from s : UML2!uml::Package (thisModule.includedPackages->includes(s))
	using {
		refs : Set(UML2!uml::Package) = s->references();
		compatiblePacks : Sequence(UML2!uml::Package) = s->compatibleInPrev()->debug(s.qualifiedName + ' compatible packages');
		equivalentPacks : Sequence(UML2!uml::Package) = compatiblePacks->select(p|p->isCompatibleWith(s))->debug(s.qualifiedName + ' equivalent packages');
		compatibleClasses : Sequence(OWL!owl::OWLClass) = compatiblePacks->collect(p|p->owlClassesInPrev())->flatten();
		equivalentClasses : Sequence(OWL!owl::OWLClass) = equivalentPacks->collect(p|p->owlClassesInPrev())->flatten();
		superClasses : Sequence(OWL!owl::OWLClass) = compatibleClasses->select(c|equivalentClasses->excludes(c));
	}
	to t : OWL!owl::OWLClass mapsTo s (
		localName <- s->ontClassName()->debug('Package'),
		RDFSSubClassOf <- if superClasses->isEmpty()
			then thisModule.javaLibrary else superClasses endif,
		OWLEquivalentClass <- if equivalentClasses->isEmpty()
			then Sequence{} else equivalentClasses endif,
		RDFSComment <- Sequence{comment},
		RDFSSeeAlso <- refs,
		namespace <- s->getModel()),
	   comment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- s->qualifiedName('.') + ' for ' + s->getModel().name),
	   platform : OWL!owl::OWLClass (
	   	localName <- (s->ontClassName() + 'Platform'),
		RDFSSubClassOf <- thisModule.platformPlatform,
		RDFSComment <- Sequence{platformcomment},
		OWLEquivalentClass <- Sequence{intersection},
		namespace <- s->getModel()),
	   platformcomment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'Platform providing ' + comment.lexicalForm),
	   intersection : OWL!owl::IntersectionClass (
	   	OWLIntersectionOf <- refs->collect(p|thisModule->PlatformClass(p))
			->union(Set{thisModule->PlatformClass(s)}),
	   	namespace <- s->getModel())
}

rule PlatformClass(p : UML2!uml::Package) {
	to platform : OWL!owl::SomeValuesFromRestriction (
		RDFSSubClassOf <- thisModule.platformPlatform,
		OWLOnProperty <- thisModule.platformProvidesFeature,
		OWLSomeValuesFrom <- p,
		namespace <- p->getModel())
	do {
		platform;
	}
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
