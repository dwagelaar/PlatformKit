-- @atlcompiler atl2006
-- $Id$
-- Base module for transforming a UML2 model to an API OWL ontology
module UML2ToAPIOntology; --abstract

create OUT : OWL from IN : UML2, PLATFORM : OWL, JAVA : OWL;--, PREVOUT : OWL, PREVIN : UML2;

--uses APIOntologyLib;

-- ======================================================================
-- helper attributes begin
-- ======================================================================

helper def : inElements : Set(UML2!ecore::EObject) = UML2!ecore::EObject->allInstancesFrom('IN');

helper def : includedPackages : Set(UML2!uml::Package) = UML2!uml::Package->allInstancesFrom('IN')
	->select(p|p->oclIsTypeOf(UML2!uml::Package) and p.packagedElement
		->select(c|c->oclIsKindOf(UML2!uml::Class) or c->oclIsKindOf(UML2!uml::Interface))->notEmpty());

helper def : includedClassifiers : Set(UML2!uml::Classifier) =  UML2!uml::Classifier->allInstancesFrom('IN')
	->select(c|c->oclIsKindOf(UML2!uml::Class) or c->oclIsKindOf(UML2!uml::Interface));

helper def : platformPlatform : Set(OWL!owl::OWLClass) = OWL!owl::OWLClass->allInstancesFrom('PLATFORM')
	->select(o|o.localName = 'Platform');

helper def : javaLibrary : Set(OWL!owl::OWLClass) = OWL!owl::OWLClass->allInstancesFrom('JAVA')
	->select(o|o.localName = 'JavaLibrary');

helper def : javaJRE : Set(OWL!owl::OWLClass) = OWL!owl::OWLClass->allInstancesFrom('JAVA')
	->select(o|o.localName = 'JRE');

helper def : platformProvidesFeature : OWL!owl::OWLObjectProperty =
	OWL!owl::OWLObjectProperty->allInstancesFrom('PLATFORM')
		->select(p|p.localName = 'providesFeature')->first();

helper def : jreProvidesBuiltinJavaLibrary : OWL!owl::OWLObjectProperty =
	OWL!owl::OWLObjectProperty->allInstancesFrom('JAVA')
		->select(p|p.localName = 'providesBuiltinJavaLibrary')->first();

helper def : platformOntology : Set(OWL!owl::OWLOntology) = 
	OWL!owl::OWLOntology->allInstancesFrom('PLATFORM');

helper def : javaOntology : Set(OWL!owl::OWLOntology) = 
	OWL!owl::OWLOntology->allInstancesFrom('JAVA');

helper def : importedOntologies : Set(OWL!owl::OWLOntology) = 
	OWL!owl::OWLOntology->allInstances()->select(o|
		OWL!owl::OWLOntology->allInstancesFrom('PLATFORM')->excludes(o) and
		OWL!owl::OWLOntology->allInstancesFrom('JAVA')->excludes(o));

helper def : prevModels : Set(UML2!uml::Model) = 
	UML2!uml::Model->allInstances()->select(m|
		UML2!uml::Model->allInstancesFrom('IN')->excludes(m));

helper def : prevPackages : Set(UML2!uml::Package) = 
	UML2!uml::Package->allInstances()->select(p|
		UML2!uml::Package->allInstancesFrom('IN')->excludes(p));

helper def : ontClassNames : Map(UML2!uml::NamedElement, String) =
	UML2!uml::Package->allInstances()->union(
	UML2!uml::Classifier->allInstances())
		->select(n|not n.name->oclIsUndefined())
		->iterate(
			e; acc : Map(UML2!uml::NamedElement, String) = Map{} |
			acc->including(e, e->ontClassName()));

helper def : qualifiedNames : Map(UML2!uml::NamedElement, String) =
	UML2!uml::Package->allInstances()->union(
	UML2!uml::Type->allInstances())
		->select(n|not n.name->oclIsUndefined())
		->iterate(
			e; acc : Map(UML2!uml::NamedElement, String) = Map{} |
			acc->including(e, e->qualifiedName('::')));

helper def : allOwnedClassifiers : Map(UML2!uml::Package, Sequence(UML2!uml::Classifier)) =
	UML2!uml::Package->allInstances()
		->iterate(
			e; acc : Map(UML2!uml::Package, Sequence(UML2!uml::Classifier)) = Map{} |
			acc->including(e, e->allOwnedClassifiers()));

helper def : classifierReferences : Map(UML2!uml::Classifier, Set(UML2!uml::Classifier)) =
	UML2!uml::Classifier->allInstancesFrom('IN')
		->select(c|c->oclIsKindOf(UML2!uml::Class) or c->oclIsKindOf(UML2!uml::Interface))
		->iterate(
			e; acc : Map(UML2!uml::Classifier, Set(UML2!uml::Classifier)) = Map{} |
			acc->including(e, e->references()));

-- ======================================================================
-- helper attributes end
-- ======================================================================

-- ======================================================================
-- general helper methods
-- ======================================================================

helper context UML2!uml::NamedElement def : qualifiedName(separator : String) : String =
	if self.owner->oclIsTypeOf(UML2!uml::Package) or self.owner->oclIsKindOf(UML2!uml::Classifier) then
		self.owner->qualifiedName(separator) + separator + self.name
	else
		self.name
	endif;

helper context UML2!uml::NamedElement def : getQualifiedName() : String =
	let qualifiedName : String = thisModule.qualifiedNames->get(self) in
		if qualifiedName->oclIsUndefined() then
			self.name
		else
			qualifiedName
		endif;

helper context String def: firstToUpper() : String =
	self->substring(1, 1)->toUpper() + self->substring(2, self->size());

helper context UML2!uml::NamedElement def : ontClassName() : String =
	if self.owner->oclIsTypeOf(UML2!uml::Package) then
		self.owner->ontClassName()
	else '' endif
	+ self.name->firstToUpper();

helper context UML2!uml::Package def : allOwnedClassifiers() : Sequence(UML2!uml::Classifier) =
	self->allOwnedElements()
		->select(o|o->oclIsKindOf(UML2!uml::Class) or o->oclIsKindOf(UML2!uml::Interface))
		->select(c|c->getNearestPackage() = self);

-- ======================================================================
-- helper methods for finding references
-- ======================================================================

helper context UML2!uml::Package def : references() : Set(UML2!uml::Package) =
	thisModule.allOwnedClassifiers->get(self)
--		->collect(c|c->transReferences(Set{c}))->flatten()->asSet()
		->collect(c|thisModule.classifierReferences->get(c))->flatten()->asSet()
		->collect(r|r->referencesOtherPackageThan(self))->flatten()->asSet();

helper context UML2!uml::PackageableElement def : referencesOtherPackageThan(p : UML2!uml::Package) : Set(UML2!uml::Package) =
	if self->getNearestPackage() <> p then Set{self->getNearestPackage()} else Set{} endif;

-- Transitive references
--helper context UML2!uml::Classifier def : transReferences(skip : Set(UML2!uml::Classifier)) : Set(UML2!uml::Classifier) =
--	let refs : Set(UML2!uml::Classifier) = thisModule.classifierReferences->get(self)
--		->reject(c|skip->includes(c))
--	in refs->union(refs->collect(r|r->transReferences(skip->union(refs)))->flatten());
	
-- Non-transitive references
helper context UML2!uml::Classifier def : references() : Set(UML2!uml::Classifier) =
	self.general->union(
		self->suppliers()->select(s|s->oclIsKindOf(UML2!uml::Classifier)))->union(
		self.feature->collect(f|f->referencesOtherThan(self)))
	->flatten()->asSet();

helper context UML2!uml::BehavioralFeature def : referencesOtherThan(c : UML2!uml::Classifier) : Sequence(UML2!uml::Classifier) =
	self.ownedParameter->collect(p|p->referencesOtherThan(c))->flatten();

helper context UML2!uml::TypedElement def : referencesOtherThan(c : UML2!uml::Classifier) : Sequence(UML2!uml::Classifier) =
	if self.type->getModel() = c->getModel() and self.type <> c then
		if self.type->oclIsKindOf(UML2!uml::Class) or self.type->oclIsKindOf(UML2!uml::Interface)
		then Sequence{self.type} else Sequence{} endif
	else Sequence{} endif;

-- ======================================================================
-- helper methods for determining compatibility
-- ======================================================================

helper context UML2!uml::NamedElement def : owlClassesInPrev() : Sequence(OWL!owl::OWLClass) =
	OWL!owl::OWLClass->allInstances()
		->select(c|c.localName = thisModule.ontClassNames->get(self) + 'Library')
		->select(o|o.namespace.name = self->getModel().name);

helper context UML2!uml::Package def : compatibleInPrev() : Sequence(UML2!uml::Package) =
	thisModule.prevPackages
		->select(p|self->isCompatibleWith(p));

helper context UML2!uml::Classifier def : compatibleInPrev() : Sequence(UML2!uml::Classifier) =
	let packageName : String = thisModule.qualifiedNames->get(self->getNearestPackage()) in
		thisModule.prevPackages
			->select(p|thisModule.qualifiedNames->get(p) = packageName)
			->collect(p1|thisModule.allOwnedClassifiers->get(p1))->flatten()
			->select(c|self->isCompatibleWith(c));

helper context UML2!uml::Package def : isCompatibleWith(p : UML2!uml::Package) : Boolean =
	if self->namedElementIsCompatibleWith(p)
	then (let compClassifiers : Sequence(UML2!uml::Classifier) = thisModule.allOwnedClassifiers->get(p)->select(c|not self->hasOwnedClassifierCompatibleWith(c))
		  in if compClassifiers->isEmpty() then true
		  	 else compClassifiers->debug(self.qualifiedName + ' misses classifiers compatible with ')->isEmpty() endif)
	else false endif;

helper context UML2!uml::Package def : hasOwnedClassifierCompatibleWith(c : UML2!uml::Classifier) : Boolean =
	thisModule.allOwnedClassifiers->get(self)->select(o|o->isCompatibleWith(c))->notEmpty();

helper context UML2!uml::Classifier def : isCompatibleWith(c : UML2!uml::Classifier) : Boolean =
	if self->namedElementIsCompatibleWith(c) then
		if (let compGenerals : Sequence(UML2!uml::Classifier) = c.general->select(g|not self->hasGeneralCompatibleWith(g))
			  in if compGenerals->isEmpty() then true
			  	 else compGenerals->debug(self.qualifiedName + ' misses generals compatible with ')->isEmpty() endif)
		then (let compFeatures : Sequence(UML2!uml::Feature) = c->allFeatures()->select(f|not self->hasFeatureCompatibleWith(f))
			  in if compFeatures->isEmpty() then true
			  	 else compFeatures->debug(self.qualifiedName + ' misses features compatible with ')->isEmpty() endif)
		else false endif
	else false endif;

helper context UML2!uml::Classifier def : hasFeatureCompatibleWith(f : UML2!uml::Feature) : Boolean =
	self->allFeatures()->select(o|o->isCompatibleWith(f))->notEmpty();

helper context UML2!uml::StructuralFeature def : isCompatibleWith(f : UML2!uml::StructuralFeature) : Boolean =
	if self->typedElementIsCompatibleWith(f)
	then (self.isStatic = f.isStatic) and
		 (self.isReadOnly = f.isReadOnly)
	else false endif;

helper context UML2!uml::BehavioralFeature def : isCompatibleWith(f : UML2!uml::BehavioralFeature) : Boolean =
	if self->namedElementIsCompatibleWith(f)
	then (self.isStatic = f.isStatic) and
		 (if self.isAbstract then f.isAbstract else true endif)
	else false endif;

helper context UML2!uml::Parameter def : isCompatibleWith(p : UML2!uml::Parameter) : Boolean =
	if p->oclIsUndefined() then true
	else
		if self->typedElementIsCompatibleWith(p)
		then (self.direction = p.direction)
		else false endif
	endif;

helper context UML2!uml::TypedElement def : isCompatibleWith(t : UML2!uml::TypedElement) : Boolean =
	self->typedElementIsCompatibleWith(t);
	
helper context UML2!uml::NamedElement def : isCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	self->namedElementIsCompatibleWith(e);

helper context UML2!uml::NamedElement def : visibilityIsCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	if (self.visibility = #public) then true
	else if (self.visibility = #protected) then (e.visibility = #protected) or (e.visibility = #private)
	else if (self.visibility = #package) then (e.visibility = #package) or (e.visibility = #private)
	else (self.visibility = e.visibility) endif endif endif;

helper context UML2!uml::TypedElement def : typedElementIsCompatibleWith(t : UML2!uml::TypedElement) : Boolean =
	if self->namedElementIsCompatibleWith(t)
	then if self.type->oclIsUndefined()
		 then t.type->oclIsUndefined()
		 else if t.type->oclIsUndefined()
		 	  then false
			  else (self.type->getQualifiedName() = t.type->getQualifiedName()) endif endif
	else false endif;
	
helper context UML2!uml::NamedElement def : namedElementIsCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	if (self->getQualifiedName() = e->getQualifiedName()) then
		if (self->oclType() = e->oclType()) and (self->visibilityIsCompatibleWith(e)) then
			(let compSuppliers : Sequence(UML2!uml::NamedElement) = e->suppliers()->select(d|not self->hasSupplierCompatibleWith(d))
			 in if compSuppliers->isEmpty() then true
			  	 else compSuppliers->debug(self.qualifiedName + ' misses dependency suppliers compatible with ')->isEmpty() endif)
		else false endif
	else false endif;

helper context UML2!uml::Classifier def : hasGeneralCompatibleWith(c : UML2!uml::Classifier) : Boolean =
	self.general->select(g|if (g->getQualifiedName() = c->getQualifiedName()) then true else g->hasGeneralCompatibleWith(c) endif)->notEmpty();

helper context UML2!uml::Classifier def : hasSupplierCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	if self->namedElementHasSupplierCompatibleWith(e) then true
	else self.general->select(g|g.hasSupplierCompatibleWith(e))->notEmpty() endif;

helper context UML2!uml::NamedElement def : hasSupplierCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	self->namedElementHasSupplierCompatibleWith(e);

helper context UML2!uml::NamedElement def : namedElementHasSupplierCompatibleWith(e : UML2!uml::NamedElement) : Boolean =
	self->allSuppliers()
		->select(s|s->getQualifiedName() = e->getQualifiedName())->notEmpty();

helper context UML2!uml::NamedElement def : suppliers() : Set(UML2!uml::NamedElement) =
	self.clientDependency->collect(d|d.supplier
			->select(n|not n.name->oclIsUndefined())
		)->flatten()->asSet();

helper context UML2!uml::NamedElement def : allSuppliers() : Set(UML2!uml::NamedElement) =
	self.clientDependency->collect(d|d.supplier
			->union(d.supplier->collect(s1|s1.allSuppliers())->flatten())
			->select(n|not n.name->oclIsUndefined())
		)->flatten()->asSet();

-- ======================================================================
-- helper methods end
-- ======================================================================

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule PrevNamespace(o : OWL!owl::OWLOntology) {
	to n : OWL!rdfs::Namespace (
		URI <- o.namespace.URI,
		name <- o.namespace.name)
	do {
		n;
	}
}

--rule PlatformClass(e : UML2!uml::Element) {
--	to platform : OWL!owl::SomeValuesFromRestriction (
--		OWLOnProperty <- thisModule.platformProvidesFeature,
--		OWLSomeValuesFrom <- e,
--		namespace <- e->getModel())
--	do {
--		platform;
--	}
--}

-- ======================================================================
-- transformation rules end
-- ======================================================================
