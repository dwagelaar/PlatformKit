-- @atlcompiler atl2006
-- $Id$
-- Transforms a UML2 model to an API OWL ontology containing all the packages
module UML2ToPackageAPIOntology; --extends UML2ToAPIOntology

create OUT : OWL from IN : UML2, PLATFORM : OWL, JAVA : OWL;

uses UML2ToAPIOntology;

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule Model {
	from s : UML2!uml::Model (thisModule.inElements->includes(s))
	using {
		prevNotEmpty : Boolean = thisModule.prevModels->select(m|m.packagedElement->notEmpty())->notEmpty();
	}
	to n : OWL!rdfs::Namespace mapsTo s (
		URI <- 'http://ssel.vub.ac.be/platformkit/' + s.name + '#',
		name <- s.name),
	   xsd : OWL!rdfs::Namespace (
	   	URI <- 'http://www.w3.org/2001/XMLSchema#',
		name <- 'xsd'),
	   units : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Units.owl#',
		name <- 'units'),
	   platform : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Platform.owl#',
		name <- 'platform'),
	   java : OWL!rdfs::Namespace (
	   	URI <- 'http://localhost/~dennis/Java.owl#',
		name <- 'java'),
	   ont : OWL!owl::OWLOntology (
	   	localName <- '',
		namespace <- n,
		RDFSLabel <- Sequence{label},
		RDFSComment <- Sequence{comment},
		ownedNamespace <- Set{n, xsd, units, platform, java}->union(
			if prevNotEmpty	then thisModule.importedOntologies->collect(o|thisModule->PrevNamespace(o)) else Set{} endif),
-- !!! OWLImports generates bogus namespace !!!
		OWLImports <- thisModule.platformOntology->union(thisModule.javaOntology)->union(
			if prevNotEmpty then thisModule.importedOntologies else Set{} endif),
		contains <- Sequence{apiClass, jreClass}->union(
			thisModule.includedPackages->select(p|p.equivalentInPrev->isEmpty()))),
	   label : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- s.name),
	   comment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'Generated by $Id$ and ' + thisModule.UML2ToApiOntologyVersionString),
-- Assume that no entire equivalent class libraries occur
	   apiClass : OWL!owl::OWLClass (
	   	localName <- s.name->firstToUpper() + 'ClassLibrary',
		RDFSSubClassOf <- thisModule.includedPackages
			->collect(p|if p.equivalentClasses->isEmpty() then Set{p} else p.equivalentClasses endif)
			->flatten()->asSet()
			->union(s.compatibleClasses),
		RDFSComment <- Sequence{apiComment},
		namespace <- s),
	   apiComment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'JavaLibrary implementing the entire API for ' + s.name),
	   jreClass : OWL!owl::OWLClass (
	   	localName <- s.name->firstToUpper(),
		RDFSSubClassOf <- Sequence{thisModule.javaJRE, builtinJavaLibraryRestriction},
		RDFSComment <- Sequence{jreComment},
		namespace <- s),
	   jreComment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- s.name + ' Java Runtime Environment'),
	   builtinJavaLibraryRestriction : OWL!owl::SomeValuesFromRestriction (
	   	OWLOnProperty <- thisModule.jreProvidesBuiltinJavaLibrary,
		OWLSomeValuesFrom <- apiClass,
		namespace <- s)
}

rule Package {
	from s : UML2!uml::Package (
		if thisModule.includedPackages->includes(s) then
			s.equivalentInPrev->isEmpty()
		else false endif)
	to t : OWL!owl::OWLClass mapsTo s (
		localName <- (s.ontClassName + 'Library')->debug(thisModule.modelName.prefix + 'Package'),
		RDFSSubClassOf <- if s.compatibleClasses->isEmpty()
			then thisModule.javaLibrary else s.compatibleClasses endif,
		RDFSComment <- Sequence{comment},
		RDFSSeeAlso <- s.references
			->collect(r|if r.equivalentClasses->isEmpty() then Set{r} else r.equivalentClasses endif)
			->flatten()->asSet(),
		namespace <- s->getModel()),
	   comment : OWL!rdfs::PlainLiteral (
	   	language <- 'en',
		lexicalForm <- 'JavaLibrary implementing the ' + s.javaQualifiedName + ' package for ' + thisModule.modelName)
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
