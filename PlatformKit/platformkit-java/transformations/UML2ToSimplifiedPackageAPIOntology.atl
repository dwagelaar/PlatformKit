-- @atlcompiler emftvm
-- @nsURI UML2 http://www.eclipse.org/uml2/3.0.0/UML
-- @nsURI OWL http:///org/eclipse/owl.ecore
-- $Id$
-- Transforms a UML2 model to an API OWL ontology containing all the packages
-- as pre-classified OWL classes, stripped from equivalent class expressions.
module UML2ToSimplifiedPackageAPIOntology; --extends UML2ToPackageAPIOntology

create OUT : OWL from IN : UML2, PLATFORM : OWL, ISA : OWL, JAVA : OWL;

uses UML2ToAPIOntology;
uses UML2ToPackageAPIOntology;

-- ======================================================================
-- helper attributes begin
-- ======================================================================

helper def : UML2ToSimplifiedPackageAPIOntologyVersionString : String =
	'$Id$';

-- ======================================================================
-- helper attributes end
-- ======================================================================

-- ======================================================================
-- helper methods begin
-- ======================================================================

helper def : versionString() : String =
	'Generated by ' + 
	thisModule.UML2ToSimplifiedPackageAPIOntologyVersionString + ', ' + 
	thisModule.UML2ToPackageAPIOntologyVersionString + ', ' + 
	thisModule.UML2ToAPIOntologyVersionString + ', and ' +
	thisModule.UML2ComparisonVersionString;

-- ======================================================================
-- helper methods end
-- ======================================================================

-- ======================================================================
-- transformation rules begin
-- ======================================================================

rule Package {
	from s : UML2!"uml::Package" (thisModule.includedPackages->includes(s))
	using {
		superClasses : Sequence(OWL!"owl::OWLClass") = 
			s.compatibleClasses->select(c|s.equivalentClasses->excludes(c));
		apiSuperClasses : Sequence(OWL!"owl::OWLClass") = 
			s.compatibleApiClasses->select(c|s.equivalentApiClasses->excludes(c));
		librarySuperClasses : Sequence(OWL!"owl::OWLClass") = 
			s.compatibleLibraryClasses->select(c|s.equivalentLibraryClasses->excludes(c));
	}
	to apiPartClass : OWL!"owl::OWLClass" (
		localName <- (s.ontClassName).debug(thisModule.modelName.prefix + 'Package'),
		RDFSSubClassOf <- if superClasses->isEmpty()
			then thisModule.javaAPIPart else superClasses endif,
		OWLEquivalentClass <- s.equivalentClasses,
		RDFSComment <- Sequence{apiPartComment},
		RDFSSeeAlso <- s.references,
		namespace <- s.getModel()),
	   apiPartComment : OWL!"rdfs::PlainLiteral" (
	   	language <- 'en',
		lexicalForm <- 'Java API part implementing the ' + s.javaQualifiedName + ' package for ' + thisModule.modelName),
	   apiClass : OWL!"owl::OWLClass" (
		localName <- s.ontClassName + 'API',
		RDFSSubClassOf <- if apiSuperClasses->isEmpty()
			then Sequence{thisModule.javaAPI} else apiSuperClasses endif,
		OWLEquivalentClass <- s.equivalentApiClasses,
		RDFSComment <- Sequence{apiComment, apiRestriction},
		namespace <- s.getModel()),
	   apiComment : OWL!"rdfs::PlainLiteral" (
	   	language <- 'en',
		lexicalForm <- 'JavaLibrary implementing the ' + s.javaQualifiedName + ' package for ' + thisModule.modelName),
	   apiRestriction : OWL!"rdfs::PlainLiteral" (
	   	language <- 'OWLManchester',
		lexicalForm <- 'platform:comprisesInterfacePart some ' + apiPartClass.localName),
	   apiPart : OWL!"owl::Individual" (
	   	localName <- 'the' + s.ontClassName + 'Part',
		RDFType <- apiPartClass,
		namespace <- s.getModel()),
	   libraryClass : OWL!"owl::OWLClass" (
		localName <- s.ontClassName + 'ClassLibrary',
		RDFSSubClassOf <- if librarySuperClasses->isEmpty()
			then Sequence{thisModule.javaLibrary} else librarySuperClasses endif,
		OWLEquivalentClass <- s.equivalentLibraryClasses,
		RDFSComment <- Sequence{libraryComment, libraryRestriction},
		namespace <- s.getModel()),
	   libraryComment : OWL!"rdfs::PlainLiteral" (
	   	language <- 'en',
		lexicalForm <- 'JavaLibrary implementing the ' + s.javaQualifiedName + ' package for ' + thisModule.modelName),
	   libraryRestriction : OWL!"rdfs::PlainLiteral" (
	   	language <- 'OWLManchester',
		lexicalForm <- 'platform:implementsInterface some ' + apiClass.localName)
}

rule APIClass(s : UML2!"uml::Model") {
	using {
		superClasses : Sequence(OWL!"owl::OWLClass") = 
			s.compatibleApiClasses->select(c|s.equivalentApiClasses->excludes(c));
	}
	to apiClass : OWL!"owl::OWLClass" (
	   	localName <- s.name.legalOntClassName + 'API',
		RDFSSubClassOf <- thisModule.includedPackages->collect(p|thisModule.resolveTemp(p, 'apiClass'))
			->union(superClasses),
		OWLEquivalentClass <- s.equivalentApiClasses,
		RDFSComment <- Sequence{apiComment, apiRestriction},
		namespace <- s),
	   apiComment : OWL!"rdfs::PlainLiteral" (
	   	language <- 'en',
		lexicalForm <- s.name + ' API'),
	   apiRestriction : OWL!"rdfs::PlainLiteral" (
	   	language <- 'OWLManchester',
		lexicalForm <- thisModule.includedPackages
			->iterate(p; acc : String = ''|
			acc +
			if acc = '' then 'platform:comprisesInterfacePart some '
			else ' and platform:comprisesInterfacePart some ' endif +
			p.ontClassName))
	do {
		apiClass;
	}
}

rule LibraryClass(s : UML2!"uml::Model", apiClass : OWL!"owl::OWLClass") {
	using {
		superClasses : Sequence(OWL!"owl::OWLClass") = 
			s.compatibleLibraryClasses->select(c|s.equivalentLibraryClasses->excludes(c));
	}
	to libraryClass : OWL!"owl::OWLClass" (
	   	localName <- s.name.legalOntClassName + 'ClassLibrary',
		RDFSSubClassOf <- thisModule.includedPackages->collect(p|thisModule.resolveTemp(p, 'libraryClass'))
			->union(superClasses),
		OWLEquivalentClass <- s.equivalentLibraryClasses,
		RDFSComment <- Sequence{libraryComment, libraryRestriction},
		namespace <- s),
	   libraryComment : OWL!"rdfs::PlainLiteral" (
	   	language <- 'en',
		lexicalForm <- 'Java class library implementing the ' + s.name + ' API'),
	   libraryRestriction : OWL!"rdfs::PlainLiteral" (
	   	language <- 'OWLManchester',
		lexicalForm <- 'platform:implementsInterface some ' + apiClass.localName)
	do {
		Sequence{apiClass, libraryClass};
	}
}

-- ======================================================================
-- transformation rules end
-- ======================================================================
